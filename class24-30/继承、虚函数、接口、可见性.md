# C++中的继承

### C++ 继承 (Inheritance) 总结与说明

继承是面向对象编程（OOP）的四大核心特性之一，它允许我们基于已有的类来创建新的类，新的类将获得已有类的属性和行为，并可以对其进行扩展。

### 一、核心概念与目的（来自第一张图）

1. **是什么**：继承建立了类之间的**层级关系**（父子关系）。它允许我们定义一个**基类（Base Class，或父类）**，其中包含通用的功能；然后从中创建出**派生类（Derived Class，或子类）**。
2. **为什么**：继承最主要的目的是**避免代码重复（Code Duplication）**。

   * 正如第一张图所述：“它帮助我们避免写很多重复的代码...我们可以把所有通用的功能放在一个父类中”，然后让多个子类共享这些功能，无需重复编写。
3. **好处**：

   * **代码复用**：子类自动获得父类的所有公有（`public`）和保护（`protected`）成员。
   * **易于扩展**：子类可以“稍微改变一些功能或引入全新的功能”，即在继承的基础上进行定制和扩展。
   * **易于维护**：通用功能的修改只需在基类中进行一次，所有派生类都会自动生效。=

### 二、语法与实现（来自第二张图）

#### 1. 基本语法

<pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">// 基类 (Base Class)
class Entity {
public:
    float X, Y;
    void Move(float xa, float ya) {
        X += xa;
        Y += ya;
    }
};

// 派生类 (Derived Class)，使用 : 来继承
// 使用 public 继承方式
class Player : public Entity { // Player 公有继承自 Entity
public:
    const char* Name;
    void PrintName() {
        std::cout << Name << std::endl;
    }
};</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>

#### 2. 内存关系（第二张图的重要信息）

* `Entity`类：包含两个 `float`变量，大小为 **8字节**。
* `Player`类：**包含从 `Entity`继承来的 `X`, `Y`**，再加上自己的 `Name`指针，大小为 **12字节**。
* 这证明了：**创建一个派生类的对象时，该对象包含了一个完整的基类子对象（subobject）**。

#### 3. 访问与使用

<pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">int main() {
    Player p;
    p.Move(5, 5); // ✅ 正确：Player对象可以调用基类Entity的方法
    p.PrintName(); // ✅ 正确：调用自己的方法
    // p.X = 5; // 访问权限取决于继承方式，这里因为是public且Entity的成员是public，所以可以访问
}</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><br class="Apple-interchange-newline"/></div></div></pre></div></pre>

### 三、继承方式

C++提供了三种继承方式，主要作用是控制**从基类继承来的成员**在派生类中的**访问权限**。


| 继承方式      | 基类`public`成员变为    | 基类`protected`成员变为 | 基类`private`成员变为 |
| ------------- | ----------------------- | ----------------------- | --------------------- |
| **public**    | 派生类的`public`成员    | 派生类的`protected`成员 | **不可访问**          |
| **protected** | 派生类的`protected`成员 | 派生类的`protected`成员 | **不可访问**          |
| **private**   | 派生类的`private`成员   | 派生类的`private`成员   | **不可访问**          |

* **最常用的是 `public`继承**，因为它表示“是一个（is-a）”的关系，即 `Player`**是一个** `Entity`。
* `protected`和 `private`继承使用较少，它们表示“用...实现”的关系。

### 四、继承与多态（第二张图结尾的引入）

第二张图以“3.多态”结尾，这是一个至关重要的衔接。

* 继承为**多态（Polymorphism）** 提供了基础。
* **多态**允许我们使用**基类的指针或引用来操作派生类的对象**，并根据对象的实际类型来调用相应的方法（这需要借助`virtual`虚函数来实现）。
* 正是“继承 + 多态”的组合，才使得面向对象编程变得无比强大。

### 五、总结与最佳实践

1. **核心思想**：**代码复用**和**层次化抽象**。
2. **关系**：公有继承表示 **“是一个（Is-A）”** 的关系（如 `Player`**是一个** `Entity`）。
3. **不是什么**：

   * 继承不是简单的代码复制。它是一种严格的层级关系。
   * 不要为了单纯复用某个函数而使用继承，这会导致设计僵化。应考虑组合（“有一个”关系）。
4. **设计原则**：

   * **遵循“里氏替换原则”**：所有派生类对象都应该可以无缝替换其基类对象并使用。
   * **谨慎使用继承，优先使用组合**：除非确定是“Is-A”关系，否则使用组合（将类作为成员变量）可能更灵活。

**总而言之，继承是C++中构建复杂、层次清晰且易于维护的代码体系的强大工具。它通过建立类之间的层级关系来最大化代码复用，并为实现多态这一更高级的特性奠定了基石。**

# 虚函数

### C++ 虚函数 (Virtual Functions) 总结与说明

虚函数是C++实现**运行时多态（Runtime Polymorphism）** 的核心机制。它允许子类重写（override）基类的方法，并通过基类的指针或引用来调用实际对象的函数，从而实现“一个接口，多种实现”

### 一、核心作用与解决的问题

1. **问题所在（来自第一、二张图）**：

   * 没有虚函数时，如果使用**基类指针指向派生类对象**，并调用一个成员函数，编译器会根据指针的**静态类型**（即`Entity*`）来调用函数，而不是根据指针所指对象的**实际类型**（即`Player`）。
   * 这导致了非预期的行为：`PrintName(p)`输出的是 `"Entity"`而不是 `"Cherno"`。
2. **解决方案**：

   * 将基类中的函数声明为 **`virtual`**（虚函数）。
   * 这样，通过基类指针调用该函数时，程序会在运行时检查指针所指向的**实际对象类型**，并调用该对象所属类的函数版本。这就是**动态绑定（Dynamic Binding）** 或**晚期绑定（Late Binding）**。

### 二、语法与使用方法

#### 1. 声明与重写（来自第二张图）

* **在基类中**：使用 `virtual`关键字声明函数。

  <pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">class Entity {
  public:
      virtual std::string GetName() { return "Entity"; } // 声明为虚函数
  };</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>
* **在派生类中**：重新定义该函数，函数签名（返回类型、函数名、参数列表）必须与基类虚函数完全一致。

  * **C++11 `override`关键字（强烈推荐）**：在派生类函数后使用 `override`关键字。正如第三张图所述，这**可读性更好**，并能**预防拼写错误等bug**（如将`GetName`误写为`Getname`，编译器会报错）。

  <pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">class Player : public Entity {
  private:
      std::string m_Name;
  public:
      std::string GetName() override { return m_Name; } // 使用override重写
  };</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>

#### 2. 使用方式（来自第一、二张图）

通过基类指针或引用来调用，才能体现多态性。

<pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">void PrintName(Entity* entity) {
    std::cout << entity->GetName() << std::endl; // 调用哪个GetName由entity实际指向的对象决定
}

int main() {
    Entity* e = new Entity();
    Player* p = new Player("Cherno");

    PrintName(e); // 输出 "Entity"
    PrintName(p); // 输出 "Cherno" —— 多态生效！
}</code></div></div></pre></div></pre>

### 三、实现原理：虚表（vtable）与动态绑定

1. **虚表 (vtable)**（来自第二张图）：

   * 编译器会为**包含虚函数的类**自动生成一个虚函数表（vtable）。
   * vtable 是一个函数指针数组，存储了该类所有虚函数的实际地址。
2. **虚表指针 (vptr)**：

   * 包含虚函数的类的每个对象内部都会隐含一个指针（vptr），在对象构造时被初始化，指向该类的 vtable。
3. **动态绑定过程**：

   * 当通过基类指针调用虚函数（如 `entity->GetName()`）时，程序会：
     1. 通过 `entity`找到实际对象的 vptr。
     2. 通过 vptr 找到该对象实际类型的 vtable。
     3. 在 vtable 中找到 `GetName`函数的地址。
     4. 调用该地址指向的函数（即 `Player::GetName`）。

### 四、运行时成本（Runtime Cost）（来自第三张图）

使用虚函数不是没有代价的，主要有两方面开销：

1. **内存开销**：

   * 每个包含虚函数的类的对象都会增大一个指针（vptr）的大小（通常4或8字节）。
   * 每个类会产生一个 vtable，占用一定的静态存储空间。
2. **性能开销**：

   * 每次调用虚函数都需要一次额外的间接寻址（通过vptr和vtable），这比直接调用非虚函数多一次指针解引用。
3. **现代上下文中的影响**：

   * 正如第三张图所说：“**除非是CPU很差的嵌入式平台...它造成的影响很小，你可能根本察觉不到。**”
   * 在绝大多数应用场景（桌面、服务器、移动应用）中，虚函数带来的灵活性远大于其微小的性能开销。**不应过度担心性能而避免使用虚函数**。

### 五、总结与最佳实践

1. **核心目的**：实现**运行时多态**，是面向对象编程中“接口与实现分离”的基石。
2. **关键语法**：

   * 基类函数前加 `virtual`。
   * 派生类函数后加 `override`（C++11起）。
3. **实现机制**：通过每个对象内部的**虚表指针 (vptr)** 和编译器生成的**虚函数表 (vtable)** 来实现动态绑定。
4. **使用场景**：当你设计一个系统，希望**通过基类接口来操作未来可能出现的各种派生类对象**时，就应使用虚函数。
5. **最佳实践**：

   * **总是使用 `override`关键字**来明确表示重写，让编译器帮你检查错误。
   * **析构函数应为虚函数**：如果一个类可能被继承，并且会通过基类指针来删除派生类对象，其析构函数必须是虚的，以确保正确释放资源。
   * **权衡使用**：在性能极其敏感的代码段（如循环内部）或内存极度受限的嵌入式系统中，需谨慎评估；否则，应大胆使用以获得良好的设计。

**总而言之，虚函数是C++实现多态性的强大工具，它虽然引入了一定的开销，但在绝大多数情况下，其带来的设计优势和代码可维护性远大于那微不足道的成本。**

# C++类与Struct的继承

### 🧩 **1. `struct`和 `class`的核心共性**

C++中的 `struct`和 `class`**在继承和多态的支持上完全一致**，均支持以下特性：

* **公有继承、保护继承、私有继承**（语法相同）。
* **多级继承**（派生类可继续被继承）。
* **虚函数和多态**（可声明 `virtual`函数和虚析构函数）。
* **多重继承**（从多个基类继承，需谨慎使用）。

---

### 🔍 **2. 唯一区别：默认访问权限**


| **特性**         | **`struct`**             | **`class`**               |
| ---------------- | ------------------------ | ------------------------- |
| **默认成员访问** | `public`                 | `private`                 |
| **默认继承权限** | `public`（若未显式指定） | `private`（若未显式指定） |

#### 示例对比：

<pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">// struct 默认公有继承
struct BaseStruct { int x; };
struct DerivedStruct : BaseStruct { }; // 等价于 : public BaseStruct

// class 默认私有继承
class BaseClass { int x; };
class DerivedClass : BaseClass { }; // 等价于 : private BaseClass</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>

---

### ⚙️ **3. 实际代码示例**

#### （1）`struct`实现继承和多态

<pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">#include <iostream>

struct Animal {
    virtual void speak() { std::cout << "Animal sound\n"; } // 虚函数
    virtual ~Animal() {} // 虚析构函数
};

struct Dog : Animal { // 公有继承（默认）
    void speak() override { std::cout << "Woof!\n"; } // 重写虚函数
};

int main() {
    Animal* animal = new Dog();
    animal->speak(); // 输出 "Woof!" （多态生效）
    delete animal;   // 正确调用派生类析构函数
}</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>

* **`struct`的继承行为与 `class`完全一致**，只需注意默认权限不同。

#### （2）显式指定继承权限

<pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">struct Base { int x; };
class Derived : Base { }; // 默认私有继承（Derived 外无法访问 Base::x）

// 等价于：
class Derived : private Base { };</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><br class="Apple-interchange-newline"/></div></div></pre></div></pre>

### ✅ **4. 使用建议**

1. **何时用 `struct`继承**：

   * 需要表示简单的“数据聚合”时（如坐标、配置项），但仍需共享基类功能。
   * 公开继承（`public`）是默认行为，符合 `struct`的“数据公开”设计哲学。
2. **何时用 `class`继承**：

   * 需要封装复杂逻辑，强调“对象行为”而非“纯数据”。
   * 默认私有继承（`private`）更符合面向对象的封装原则。
3. **通用规则**：

   * **显式声明继承权限**（如 `: public Base`），避免依赖默认行为。
   * **优先用 `class`表示有行为的对象**，用 `struct`表示纯数据或POD类型（Plain Old Data）。

---

### 📌 **5. 总结**

* **C++中的 `struct`和 `class`在继承功能上完全等价**，区别仅在于默认权限。
* `struct`默认公有继承，`class`默认私有继承，但均可通过显式声明覆盖默认行为。
* 从设计意图上，`struct`更适合“数据继承”，`class`更适合“行为继承”，但技术上无限制。

因此，**`struct`完全可以像 `class`一样使用继承**，只需根据场景选择合适的默认语义即可！

# 纯虚函数

### 一、纯虚函数的核心概念

#### 1. 什么是纯虚函数？

* **语法**：在虚函数声明后加上 `= 0`。

  <pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">virtual ReturnType FunctionName() = 0; // 纯虚函数</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>
* **含义**：该函数在基类中**只有声明，没有实现**（定义），要求任何派生类必须提供自己的实现。

#### 2. 抽象类（接口）

* **定义**：包含至少一个纯虚函数的类称为**抽象类**（Abstract Class），在C++中通常被称为**接口**（Interface）。
* **关键特性**：**抽象类不能被实例化**（如图片1中的编译错误所示）。

  <pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">Printable p; // ❌ 错误：无法创建抽象类的对象
  Printable* p = new Entity(); // ✅ 正确：可以创建指向派生类对象的指针</code></div></div></pre></div></pre>

### 二、纯虚函数的作用与设计意图

#### 1. 强制实现契约（来自图片1）

* 纯虚函数在基类中定义了一个**必须实现的契约**。
* 任何想要被实例化的派生类**必须重写（override）** 基类中的所有纯虚函数。
* **作用**：确保所有派生类都提供特定的功能，实现标准化的接口。

#### 2. 实现多态与通用编程（来自图片3和4）

* 如图片4所述：“确保这个类有个特定的方法，那么就可以将这个类作为参数传入一个通用的函数”。
* 通过接口（基类指针/引用），可以编写处理各种派生类的通用代码：

  <pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">void Print(Printable* obj) {
      std::cout << obj->GetClassName() << std::endl;
  }
  // 可以接受任何实现了Printable接口的类的对象</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>

#### 3. 定义清晰的接口规范

* 如图片2简洁明了地指出：“**Interface就是C++中的类而已**”。
* 在C++中，接口不是特殊的语言结构，而是**通过纯虚函数实现的类的设计模式**。

### 三、重要规则与特性总结

1. **抽象类规则**：

   * 包含纯虚函数的类是抽象类。
   * 不能创建抽象类的实例对象。
   * 抽象类可以有构造函数和析构函数（析构函数通常应为虚函数）。
2. **派生类责任**：

   * 如果派生类没有实现基类的所有纯虚函数，那么该派生类仍然是抽象类，也不能被实例化。
   * 只有实现了所有纯虚函数的派生类才是具体类，可以被实例化。
3. **接口继承 vs 实现继承**：

   * 纯虚函数强调**接口继承**（派生类必须提供实现）。
   * 普通虚函数允许**接口继承+默认实现继承**（派生类可选择是否重写）。

### 四、使用场景与最佳实践

1. **何时使用纯虚函数**：

   * 定义标准接口，要求所有派生类都必须实现特定方法时。
   * 设计插件系统、回调机制等需要多态的场景。
   * 创建不可实例化的基类，只作为其他类的接口规范。
2. **最佳实践**：

   * **虚析构函数**：如果类包含虚函数（特别是纯虚函数），其析构函数也应该声明为虚函数，确保正确释放资源。
   * **override关键字**：在派生类中重写纯虚函数时使用 `override`关键字，让编译器检查是否正确重写。
   * **清晰的接口设计**：接口应该定义一组相关的方法，保持接口的专注和简洁。

### 总结

纯虚函数是C++实现**接口和抽象类**的核心机制，它通过：

1. **强制契约**：要求派生类必须实现特定方法。
2. **实现多态**：允许通过基类接口操作各种派生类对象。
3. **定义规范**：建立清晰的类层次结构和设计契约。

这种机制使得C++能够实现高度灵活和可扩展的面向对象设计，是构建大型、复杂系统的重要工具



# 权限和可见性

#### **核心概念**

可见性是面向对象编程中的访问控制机制，用于控制类成员（变量和函数）的可访问范围，主要目的是实现**封装**。

#### **三种基本访问修饰符**


| 修饰符          | 访问权限             | 设计意图                   |
| --------------- | -------------------- | -------------------------- |
| **`private`**   | 仅本类内部可访问     | 完全隐藏内部实现细节       |
| **`protected`** | 本类及其派生类可访问 | 允许子类扩展，但仍对外隐藏 |
| **`public`**    | 任何地方都可访问     | 定义稳定的对外接口         |


#### **重要特性**

1. **默认权限差异**：

   * `class`默认成员访问权限为 `private`
   * `struct`默认成员访问权限为 `public`
2. **`friend`关键字**：可以突破封装限制，允许特定函数或类访问私有成员
3. **不影响性能**：可见性只是编译期概念，不影响程序运行性能

#### **最佳实践**

1. **遵循最小权限原则**：成员应设置为能满足需求的最严格权限
2. **数据封装**：成员变量通常设为 `private`，通过公有方法提供受控访问
3. **避免全公开**：将所有成员设为 `public`是糟糕的设计，会破坏封装性
