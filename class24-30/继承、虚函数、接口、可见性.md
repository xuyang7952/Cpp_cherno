# C++中的继承


### C++ 继承 (Inheritance) 总结与说明

继承是面向对象编程（OOP）的四大核心特性之一，它允许我们基于已有的类来创建新的类，新的类将获得已有类的属性和行为，并可以对其进行扩展。


### 一、核心概念与目的（来自第一张图）

1. **是什么**：继承建立了类之间的**层级关系**（父子关系）。它允许我们定义一个**基类（Base Class，或父类）**，其中包含通用的功能；然后从中创建出**派生类（Derived Class，或子类）**。
2. **为什么**：继承最主要的目的是**避免代码重复（Code Duplication）**。

   * 正如第一张图所述：“它帮助我们避免写很多重复的代码...我们可以把所有通用的功能放在一个父类中”，然后让多个子类共享这些功能，无需重复编写。
3. **好处**：

   * **代码复用**：子类自动获得父类的所有公有（`public`）和保护（`protected`）成员。
   * **易于扩展**：子类可以“稍微改变一些功能或引入全新的功能”，即在继承的基础上进行定制和扩展。
   * **易于维护**：通用功能的修改只需在基类中进行一次，所有派生类都会自动生效。=

### 二、语法与实现（来自第二张图）

#### 1. 基本语法

<pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">// 基类 (Base Class)
class Entity {
public:
    float X, Y;
    void Move(float xa, float ya) {
        X += xa;
        Y += ya;
    }
};

// 派生类 (Derived Class)，使用 : 来继承
// 使用 public 继承方式
class Player : public Entity { // Player 公有继承自 Entity
public:
    const char* Name;
    void PrintName() {
        std::cout << Name << std::endl;
    }
};</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>

#### 2. 内存关系（第二张图的重要信息）

* `Entity`类：包含两个 `float`变量，大小为 **8字节**。
* `Player`类：**包含从 `Entity`继承来的 `X`, `Y`**，再加上自己的 `Name`指针，大小为 **12字节**。
* 这证明了：**创建一个派生类的对象时，该对象包含了一个完整的基类子对象（subobject）**。

#### 3. 访问与使用

<pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">int main() {
    Player p;
    p.Move(5, 5); // ✅ 正确：Player对象可以调用基类Entity的方法
    p.PrintName(); // ✅ 正确：调用自己的方法
    // p.X = 5; // 访问权限取决于继承方式，这里因为是public且Entity的成员是public，所以可以访问
}</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><br class="Apple-interchange-newline"/></div></div></pre></div></pre>


### 三、继承方式

C++提供了三种继承方式，主要作用是控制**从基类继承来的成员**在派生类中的**访问权限**。


| 继承方式      | 基类`public`成员变为    | 基类`protected`成员变为 | 基类`private`成员变为 |
| ------------- | ----------------------- | ----------------------- | --------------------- |
| **public**    | 派生类的`public`成员    | 派生类的`protected`成员 | **不可访问**          |
| **protected** | 派生类的`protected`成员 | 派生类的`protected`成员 | **不可访问**          |
| **private**   | 派生类的`private`成员   | 派生类的`private`成员   | **不可访问**          |

* **最常用的是 `public`继承**，因为它表示“是一个（is-a）”的关系，即 `Player`**是一个** `Entity`。
* `protected`和 `private`继承使用较少，它们表示“用...实现”的关系。


### 四、继承与多态（第二张图结尾的引入）

第二张图以“3.多态”结尾，这是一个至关重要的衔接。

* 继承为**多态（Polymorphism）** 提供了基础。
* **多态**允许我们使用**基类的指针或引用来操作派生类的对象**，并根据对象的实际类型来调用相应的方法（这需要借助`virtual`虚函数来实现）。
* 正是“继承 + 多态”的组合，才使得面向对象编程变得无比强大。


### 五、总结与最佳实践

1. **核心思想**：**代码复用**和**层次化抽象**。
2. **关系**：公有继承表示 **“是一个（Is-A）”** 的关系（如 `Player`**是一个** `Entity`）。
3. **不是什么**：

   * 继承不是简单的代码复制。它是一种严格的层级关系。
   * 不要为了单纯复用某个函数而使用继承，这会导致设计僵化。应考虑组合（“有一个”关系）。
4. **设计原则**：

   * **遵循“里氏替换原则”**：所有派生类对象都应该可以无缝替换其基类对象并使用。
   * **谨慎使用继承，优先使用组合**：除非确定是“Is-A”关系，否则使用组合（将类作为成员变量）可能更灵活。

**总而言之，继承是C++中构建复杂、层次清晰且易于维护的代码体系的强大工具。它通过建立类之间的层级关系来最大化代码复用，并为实现多态这一更高级的特性奠定了基石。**


# 虚函数


### C++ 虚函数 (Virtual Functions) 总结与说明

虚函数是C++实现**运行时多态（Runtime Polymorphism）** 的核心机制。它允许子类重写（override）基类的方法，并通过基类的指针或引用来调用实际对象的函数，从而实现“一个接口，多种实现”


### 一、核心作用与解决的问题

1. **问题所在（来自第一、二张图）**：

   * 没有虚函数时，如果使用**基类指针指向派生类对象**，并调用一个成员函数，编译器会根据指针的**静态类型**（即`Entity*`）来调用函数，而不是根据指针所指对象的**实际类型**（即`Player`）。
   * 这导致了非预期的行为：`PrintName(p)`输出的是 `"Entity"`而不是 `"Cherno"`。
2. **解决方案**：

   * 将基类中的函数声明为 **`virtual`**（虚函数）。
   * 这样，通过基类指针调用该函数时，程序会在运行时检查指针所指向的**实际对象类型**，并调用该对象所属类的函数版本。这就是**动态绑定（Dynamic Binding）** 或**晚期绑定（Late Binding）**。

### 二、语法与使用方法

#### 1. 声明与重写（来自第二张图）

* **在基类中**：使用 `virtual`关键字声明函数。

  <pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">class Entity {
  public:
      virtual std::string GetName() { return "Entity"; } // 声明为虚函数
  };</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>
* **在派生类中**：重新定义该函数，函数签名（返回类型、函数名、参数列表）必须与基类虚函数完全一致。

  * **C++11 `override`关键字（强烈推荐）**：在派生类函数后使用 `override`关键字。正如第三张图所述，这**可读性更好**，并能**预防拼写错误等bug**（如将`GetName`误写为`Getname`，编译器会报错）。

  <pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">class Player : public Entity {
  private:
      std::string m_Name;
  public:
      std::string GetName() override { return m_Name; } // 使用override重写
  };</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>

#### 2. 使用方式（来自第一、二张图）

通过基类指针或引用来调用，才能体现多态性。

<pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">void PrintName(Entity* entity) {
    std::cout << entity->GetName() << std::endl; // 调用哪个GetName由entity实际指向的对象决定
}

int main() {
    Entity* e = new Entity();
    Player* p = new Player("Cherno");

    PrintName(e); // 输出 "Entity"
    PrintName(p); // 输出 "Cherno" —— 多态生效！
}</code></div></div></pre></div></pre>



### 三、实现原理：虚表（vtable）与动态绑定

1. **虚表 (vtable)**（来自第二张图）：

   * 编译器会为**包含虚函数的类**自动生成一个虚函数表（vtable）。
   * vtable 是一个函数指针数组，存储了该类所有虚函数的实际地址。
2. **虚表指针 (vptr)**：

   * 包含虚函数的类的每个对象内部都会隐含一个指针（vptr），在对象构造时被初始化，指向该类的 vtable。
3. **动态绑定过程**：

   * 当通过基类指针调用虚函数（如 `entity->GetName()`）时，程序会：
     1. 通过 `entity`找到实际对象的 vptr。
     2. 通过 vptr 找到该对象实际类型的 vtable。
     3. 在 vtable 中找到 `GetName`函数的地址。
     4. 调用该地址指向的函数（即 `Player::GetName`）。


### 四、运行时成本（Runtime Cost）（来自第三张图）

使用虚函数不是没有代价的，主要有两方面开销：

1. **内存开销**：

   * 每个包含虚函数的类的对象都会增大一个指针（vptr）的大小（通常4或8字节）。
   * 每个类会产生一个 vtable，占用一定的静态存储空间。
2. **性能开销**：

   * 每次调用虚函数都需要一次额外的间接寻址（通过vptr和vtable），这比直接调用非虚函数多一次指针解引用。
3. **现代上下文中的影响**：

   * 正如第三张图所说：“**除非是CPU很差的嵌入式平台...它造成的影响很小，你可能根本察觉不到。**”
   * 在绝大多数应用场景（桌面、服务器、移动应用）中，虚函数带来的灵活性远大于其微小的性能开销。**不应过度担心性能而避免使用虚函数**。


### 五、总结与最佳实践

1. **核心目的**：实现**运行时多态**，是面向对象编程中“接口与实现分离”的基石。
2. **关键语法**：

   * 基类函数前加 `virtual`。
   * 派生类函数后加 `override`（C++11起）。
3. **实现机制**：通过每个对象内部的**虚表指针 (vptr)** 和编译器生成的**虚函数表 (vtable)** 来实现动态绑定。
4. **使用场景**：当你设计一个系统，希望**通过基类接口来操作未来可能出现的各种派生类对象**时，就应使用虚函数。
5. **最佳实践**：

   * **总是使用 `override`关键字**来明确表示重写，让编译器帮你检查错误。
   * **析构函数应为虚函数**：如果一个类可能被继承，并且会通过基类指针来删除派生类对象，其析构函数必须是虚的，以确保正确释放资源。
   * **权衡使用**：在性能极其敏感的代码段（如循环内部）或内存极度受限的嵌入式系统中，需谨慎评估；否则，应大胆使用以获得良好的设计。

**总而言之，虚函数是C++实现多态性的强大工具，它虽然引入了一定的开销，但在绝大多数情况下，其带来的设计优势和代码可维护性远大于那微不足道的成本。**
