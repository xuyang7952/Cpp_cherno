# C++模板Templates


## 一、什么是模板（Templates）

C++ 中的 **模板（Template）** 是一种强大的泛型编程工具，它允许你编写与类型无关的代码。编译器会在编译时根据你使用的具体类型，自动“实例化”出对应的函数或类。

> 💡 **核心思想**：写一次代码，适用于多种类型。

与其它语言的“泛型”相比，C++ 模板更强大，因为它在编译时进行“元编程”，可以生成针对不同类型的高度优化代码。


## 二、模板的两种主要形式

### 1️⃣ 函数模板（Function Templates）

用于创建能处理多种类型的通用函数。

#### 基本语法：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>template</span><span> <</span><span>typename</span><span> T>
</span>返回类型 函数名(T 参数) {
<span>    </span><span>// 函数体</span><span>
</span>}</code></pre></div></div></pre>

#### 示例：通用打印函数

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>#</span>include<span> </span><iostream><span>
</span><span></span><span>#</span>include<span> </span><string><span>
</span>
<span></span><span>// 定义一个函数模板</span><span>
</span><span></span><span>template</span><span> <</span><span>typename</span><span> T>
</span><span></span>void Print(T value) <span>{
</span><span>    </span><span>std</span><span>::</span><span>cout</span><span> << value << </span><span>std</span><span>::</span><span>endl</span><span>;
</span>}

<span></span>int main() <span>{
</span><span>    Print(</span>5<span>);           </span><span>// 调用 Print<int>(5)</span><span>
</span><span>    Print(</span><span>"Hello"</span><span>);     </span><span>// 调用 Print<const char*>(const char*)</span><span>
</span><span>    Print(</span>3.14f<span>);       </span><span>// 调用 Print<float>(3.14f)</span><span>
</span><span>    </span><span>return</span><span> </span>0<span>;
</span>}</code></pre></div></div></pre>

> ✅ 编译器会为 `int`、`const char*`、`float` 分别生成三个不同的 `Print` 函数。

---

### 2️⃣ 类模板（Class Templates）

用于创建能处理多种类型的通用类。

#### 基本语法：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>template</span><span> <</span><span>typename</span><span> T, </span><span>int</span><span> N>
</span><span></span>class 类名 {<span>
</span><span>    T data[N]; </span><span>// 使用模板参数</span><span>
</span>};</code></pre></div></div></pre>

#### 示例：固定大小的通用数组类

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>template</span><span> <</span><span>typename</span><span> T, </span><span>int</span><span> N>
</span><span></span>class Array {<span>
</span><span></span><span>private</span><span>:
</span>    T m_Array[N];
<span></span><span>public</span><span>:
</span><span>    </span>int GetSize() const <span>{
</span><span>        </span><span>return</span><span> N;
</span>    }

<span>    T& </span><span>operator</span><span>[](</span><span>int</span><span> index) {
</span><span>        </span><span>return</span><span> m_Array[index];
</span>    }
};

<span></span>int main() <span>{
</span><span>    Array<</span><span>int</span><span>, </span>5<span>> intArray;           </span><span>// 存放5个int的数组</span><span>
</span><span>    Array<</span><span>std</span><span>::</span><span>string</span><span>, </span>3<span>> strArray;   </span><span>// 存放3个string的数组</span><span>
</span>
<span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"intArray size: "</span><span> << intArray.GetSize() << </span><span>std</span><span>::</span><span>endl</span><span>; </span><span>// 5</span><span>
</span><span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"strArray size: "</span><span> << strArray.GetSize() << </span><span>std</span><span>::</span><span>endl</span><span>; </span><span>// 3</span><span>
</span>
<span>    intArray[</span>0<span>] = </span>10<span>;
</span><span>    strArray[</span>0<span>] = </span><span>"Hello"</span><span>;
</span>
<span>    </span><span>std</span><span>::</span><span>cout</span><span> << intArray[</span>0<span>] << </span><span>", "</span><span> << strArray[</span>0<span>] << </span><span>std</span><span>::</span><span>endl</span><span>; </span><span>// 10, Hello</span><span>
</span>
<span>    </span><span>return</span><span> </span>0<span>;
</span>}</code></pre></div></div></pre>

> ✅ 这类似于 `std::array<T, N>` 的简化版。


## 四、完整可运行代码（包含所有示例）

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>#</span>include<span> </span><iostream><span>
</span><span></span><span>#</span>include<span> </span><string><span>
</span>
<span></span><span>// ==================== 1. 函数模板 ====================</span><span>
</span><span></span><span>template</span><span> <</span><span>typename</span><span> T>
</span><span></span>void Print(T value) <span>{
</span><span>    </span><span>std</span><span>::</span><span>cout</span><span> << value << </span><span>std</span><span>::</span><span>endl</span><span>;
</span>}

<span></span><span>// ==================== 2. 类模板 - 通用数组 ====================</span><span>
</span><span></span><span>template</span><span> <</span><span>typename</span><span> T, </span><span>int</span><span> N>
</span><span></span>class Array {<span>
</span><span></span><span>private</span><span>:
</span>    T m_Array[N];
<span></span><span>public</span><span>:
</span><span>    </span>int GetSize() const <span>{
</span><span>        </span><span>return</span><span> N;
</span>    }

<span>    T& </span><span>operator</span><span>[](</span><span>int</span><span> index) {
</span><span>        </span><span>return</span><span> m_Array[index];
</span>    }
};

<span></span><span>// ==================== 3. 类模板 - 固定缓冲区 ====================</span><span>
</span><span></span><span>template</span><span> <</span><span>int</span><span> N>
</span><span></span>class FixedBuffer {<span>
</span><span></span><span>private</span><span>:
</span><span>    </span><span>char</span><span> buffer[N];
</span><span></span><span>public</span><span>:
</span><span>    </span>void Set(char c) <span>{
</span><span>        </span><span>for</span><span> (</span><span>int</span><span> i = </span>0<span>; i < N; ++i)
</span>            buffer[i] = c;
    }
<span>    </span>int Size() const <span>{ </span><span>return</span><span> N; }
</span>};

<span></span><span>// ==================== 主函数测试 ====================</span><span>
</span><span></span>int main() <span>{
</span><span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"=== 函数模板 ==="</span><span> << </span><span>std</span><span>::</span><span>endl</span><span>;
</span><span>    Print(</span>5<span>);
</span><span>    Print(</span><span>"Hello"</span><span>);
</span><span>    Print(</span>3.14f<span>);
</span>
<span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"\n=== 类模板：Array ==="</span><span> << </span><span>std</span><span>::</span><span>endl</span><span>;
</span><span>    Array<</span><span>int</span><span>, </span>5<span>> intArray;
</span><span>    Array<</span><span>std</span><span>::</span><span>string</span><span>, </span>3<span>> strArray;
</span>
<span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"intArray size: "</span><span> << intArray.GetSize() << </span><span>std</span><span>::</span><span>endl</span><span>;
</span><span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"strArray size: "</span><span> << strArray.GetSize() << </span><span>std</span><span>::</span><span>endl</span><span>;
</span>
<span>    intArray[</span>0<span>] = </span>42<span>;
</span><span>    strArray[</span>0<span>] = </span><span>"World"</span><span>;
</span><span>    </span><span>std</span><span>::</span><span>cout</span><span> << intArray[</span>0<span>] << </span><span>", "</span><span> << strArray[</span>0<span>] << </span><span>std</span><span>::</span><span>endl</span><span>;
</span>
<span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"\n=== 类模板：FixedBuffer ==="</span><span> << </span><span>std</span><span>::</span><span>endl</span><span>;
</span><span>    FixedBuffer<</span>8<span>> smallBuf;
</span><span>    FixedBuffer<</span>64<span>> largeBuf;
</span>
<span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"smallBuf size: "</span><span> << smallBuf.Size() << </span><span>std</span><span>::</span><span>endl</span><span>;  </span><span>// 8</span><span>
</span><span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"largeBuf size: "</span><span> << largeBuf.Size() << </span><span>std</span><span>::</span><span>endl</span><span>;  </span><span>// 64</span><span>
</span>
<span>    </span><span>return</span><span> </span>0<span>;
</span>}</code></pre></div></div></pre>


## 三、模板参数的多样性

模板不仅可以接受**类型参数**（`typename T`），还可以接受**非类型参数**（如整数、指针等）。

#### 示例：仅使用整数作为模板参数

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code data-spm-anchor-id="5176.28103460.0.i19.49f02e31CElpBX"><span>template</span><span> <</span><span>int</span><span> N>
</span><span></span>class FixedBuffer {<span>
</span><span></span><span>private</span><span>:
</span><span>    </span><span>char</span><span> buffer[N];
</span><span></span><span>public</span><span>:
</span><span>    </span>void Set(char c) <span>{
</span><span>        </span><span>for</span><span> (</span><span>int</span><span> i = </span>0<span>; i < N; ++i)
</span>            buffer[i] = c;
    }
<span>    </span>int Size() const <span>{ </span><span>return</span><span> N; }
</span>};

<span></span>int main() <span>{
</span><span>    FixedBuffer<</span>10<span>> buf1;
</span><span>    FixedBuffer<</span>100<span>> buf2;
</span>
<span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"buf1 size: "</span><span> << buf1.Size() << </span><span>std</span><span>::</span><span>endl</span><span>; </span><span>// 10</span><span>
</span><span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"buf2 size: "</span><span> << buf2.Size() << </span><span>std</span><span>::</span><span>endl</span><span>; </span><span>// 100</span><span>
</span>
<span>    </span><span>return</span><span> </span>0<span>;
</span>}</code></pre></div></div></pre>

> ✅ `N` 是一个编译时常量，决定了数组大小。


## 五、模板的关键特性总结


| 特性             | 说明                                                             |
| ---------------- | ---------------------------------------------------------------- |
| **编译时实例化** | 模板代码只在被调用时才生成实际函数/类，否则不生成。              |
| **零运行时开销** | 生成的是具体类型的代码，性能与手写一样。                         |
| **支持多种参数** | 可以是类型（`typename T`）、整数（`int N`）、甚至函数指针。      |
| **元编程能力**   | 在编译时“编程”，实现高度灵活的通用代码。                       |
| **STL 的基础**   | `std::vector<T>`、`std::array<T,N>`、`std::list<T>` 等都是模板。 |


## 六、使用建议（Cherno 观点）

* ✅ **推荐使用场景**：
  * 日志系统（打印任意类型）
  * 容器类（如 `Array<T, N>`）
  * 工具函数（如 `Max<T>`, `Swap<T>`）
  * 游戏引擎中的材质、资源管理等
* ❌ **避免滥用**：
  * 不要为了“炫技”而写复杂的模板
  * 模板过深会导致编译错误难以理解
  * 团队协作中应保持简洁和可读性

> 💬 **Cherno 的观点**：
> “模板不应该被完全禁止，但也不应该滥用。手动写一些代码，反而能让团队更好地理解和维护。”


## 七、结论

C++ 模板是实现**泛型编程**的核心工具：

* 使用 `template <typename T>` 创建通用函数和类。
* 支持类型和非类型参数，灵活性极高。
* 是 STL 的基石，广泛应用于现代 C++ 开发。
* 推荐在需要**类型通用性**的场景中使用，但应避免过度复杂化。

> ✅ **最佳实践**：从简单的函数模板开始，逐步掌握类模板，在项目中合理使用，提升代码复用性和可维护性。

# 为什么用模板


## 问题重述

我们有这样一个类：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>template</span><span> <</span><span>int</span><span> N>
</span><span></span>class FixedBuffer {<span>
</span><span></span><span>private</span><span>:
</span><span>    </span><span>char</span><span> buffer[N];
</span><span></span><span>public</span><span>:
</span><span>    </span>void Set(char c) <span>{
</span><span>        </span><span>for</span><span> (</span><span>int</span><span> i = </span>0<span>; i < N; ++i)
</span>            buffer[i] = c;
    }
<span>    </span>int Size() const <span>{ </span><span>return</span><span> N; }
</span>};</code></pre></div></div></pre>

你问：**既然 `N` 是一个正整数，为什么不写成这样？**

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code>class FixedBuffer {<span>
</span><span></span><span>private</span><span>:
</span><span>    </span><span>int</span><span> size;
</span><span>    </span><span>char</span><span>* buffer;  </span><span>// 或 std::vector<char></span><span>
</span><span></span><span>public</span><span>:
</span><span>    FixedBuffer(</span><span>int</span><span> n) : size(n), buffer(</span><span>new</span><span> </span><span>char</span><span>[n]) {}
</span><span>    ~FixedBuffer() { </span><span>delete</span><span>[] buffer; }
</span><span>    </span>void Set(char c)<span>;
</span><span>    </span>int Size() const <span>{ </span><span>return</span><span> size; }
</span>};</code></pre></div></div></pre>


## 为什么使用模板 `template<int N>` 更好？

### 1. **内存分配位置不同：栈 vs 堆**


| 方式                | 内存位置     | 性能                        | 安全性                      |
| ------------------- | ------------ | --------------------------- | --------------------------- |
| `template<int N>`   | **栈上分配** | ⚡ 极快，无动态分配开销     | ✅ 无内存泄漏风险           |
| 构造函数传参`int n` | **堆上分配** | ⚠️ 较慢（`new`/`delete`） | ❌ 可能内存泄漏，需手动管理 |

> ✅ **优势**：模板版本在栈上分配 `buffer[N]`，**无需动态内存管理**，性能更高，更安全。

---

### 2. **大小在编译时已知 → 编译器可优化**

当 `N` 是模板参数时，它是一个**编译时常量**。

这意味着编译器可以在编译时进行大量优化：

* **循环展开（Loop Unrolling）**：

  <pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>for</span><span> (</span><span>int</span><span> i = </span>0<span>; i < N; ++i) buffer[i] = c;</span></code></pre></div></div></pre>

  如果 `N=4`，编译器可能优化为：

  <pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>buffer[0] = c;
  </span>buffer[1] = c;
  buffer[2] = c;
  buffer[3] = c;</code></pre></div></div></pre>

  完全消除循环开销。
* **内联优化**：`Size()` 可能被完全内联为常量 `N`。

> ✅ **优势**：生成的代码更高效，接近手写汇编。

---

### 3. **类型安全与接口约束**

使用模板 `template<int N>` 意味着：

* `N` 必须在**编译时确定**。
* `N` 必须是**常量表达式**（如 `8`, `1024`，不能是变量）。

这带来了**设计上的约束**：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>FixedBuffer<</span>8<span>>  buf1;   </span><span>// ✅ 合法</span><span>
</span><span>FixedBuffer<</span>100<span>> buf2;  </span><span>// ✅ 合法</span><span>
</span>
<span></span><span>int</span><span> n = </span>10<span>;
</span><span>FixedBuffer<n> buf3;    </span><span>// ❌ 编译错误！n 不是编译时常量</span></code></pre></div></div></pre>

> ✅ **优势**：防止运行时传入非法大小，保证了对象大小的确定性。

而如果用构造函数传参，你无法阻止用户传入 `new FixedBuffer(-1)` 或 `new FixedBuffer(1000000)`，可能导致崩溃或性能问题。

---

### 4. **每个 `N` 生成独立类型**

模板为每个不同的 `N` 生成一个**独立的类类型**：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>FixedBuffer<</span>8<span>>  a;
</span><span>FixedBuffer<</span>16<span>> b;
</span><span>FixedBuffer<</span>8<span>>  c;
</span>
<span></span><span>// a 和 c 是同一类型，b 是不同类型</span><span>
</span><span></span><span>static_assert</span><span>(</span><span>std</span><span>::is_same_v<</span><span>decltype</span><span>(a), </span><span>decltype</span><span>(c)>); </span><span>// ✅</span><span>
</span><span></span><span>static_assert</span><span>(!</span><span>std</span><span>::is_same_v<</span><span>decltype</span><span>(a), </span><span>decltype</span><span>(b)>); </span><span>// ✅</span></code></pre></div></div></pre>

这在某些场景下非常有用，比如：

* 你可以为特定大小的缓冲区特化模板。
* 可以在类型系统中区分不同大小的缓冲区（类型安全）。

---

### 5. **零抽象成本（Zero-Cost Abstraction）**

这是 C++ 的核心哲学之一：**你不用为不用的东西付费**。

* 模板版本：只使用栈内存，无指针，无虚函数，无动态分配。
* 函数参数版本：需要 `new`/`delete`，可能有异常，需要析构函数。

模板版本在功能上更强大，但**运行时开销为零**。



## 什么时候应该用“构造函数传参”？

只有当你需要**运行时决定大小**时，才应该使用动态分配：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code>class DynamicBuffer {<span>
</span><span>    </span><span>std</span><span>::</span><span>vector</span><span><</span><span>char</span><span>> buffer;
</span><span></span><span>public</span><span>:
</span><span>    DynamicBuffer(</span><span>int</span><span> n) : buffer(n) {}
</span><span>    </span>void Set(char c) <span>{
</span><span>        </span><span>std</span><span>::fill(buffer.begin(), buffer.end(), c);
</span>    }
<span>    </span>size_t Size() const <span>{ </span><span>return</span><span> buffer.size(); }
</span>};</code></pre></div></div></pre>

> ✅ 适用场景：文件大小、用户输入、网络数据包等**大小未知**的情况。

---

## ✅ 总结：为什么用 `template<int N>`？


| 对比项         | `template<int N>`（模板）          | 构造函数传参                |
| -------------- | ---------------------------------- | --------------------------- |
| **内存位置**   | 栈（Stack）                        | 堆（Heap）                  |
| **性能**       | ⚡ 极快（无动态分配）              | ⚠️ 较慢（`new`/`delete`） |
| **编译时优化** | ✅ 可循环展开、内联                | ❌ 难以优化                 |
| **类型安全**   | ✅ 大小必须是编译时常量            | ❌ 可传入任意整数           |
| **内存安全**   | ✅ 无泄漏风险                      | ❌ 需手动管理或用智能指针   |
| **适用场景**   | 固定大小的缓冲区（如帧头、协议包） | 大小在运行时才知道          |

> 💡 **结论**： 如果你知道缓冲区的大小是固定的（比如 8 字节、16 字节、1024 字节），**使用 `template<int N>` 是更高效、更安全、更现代 C++ 的做法**。它利用了编译时信息，生成了最优代码。
>
> 而“传参”方式适用于大小**动态可变**的场景。



### 类比：`std::array` vs `std::vector`

* `std::array<char, N>` → 对应 `template<int N>` 版本（栈上，固定大小）
* `std::vector<char>` → 对应构造函数传参版本（堆上，动态大小）


## 一句话理解

> **C++ 模板就像是一个“在编译阶段运行的代码生成函数”，它根据类型或常量参数，为你定制出最高效的专用代码。**
