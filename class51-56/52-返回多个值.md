# **C++ 中如何返回多个值**


## 一、问题背景

C++ 函数默认只能返回**一个值**。但在实际开发中，我们经常需要从一个函数中返回多个数据，例如：

* 返回两个 `int` 值
* 返回一个 `string` 和一个 `int`
* 返回多个不同类型的值

本文介绍四种主流解决方案，并给出代码示例。


## 二、C++ 中返回多个值的四种方法

### 方法 1️⃣：通过**引用（Reference）或指针（Pointer）参数**

将变量作为引用传入函数，函数内部修改其值，实现“多返回”。

#### ✅ 优点：

* 无需额外头文件
* 性能高（无拷贝）

#### ❌ 缺点：

* 调用者必须提前创建变量
* 接口不清晰（调用者不知道哪些参数会被修改）

#### 📌 示例代码：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>#</span>include<span> </span><iostream><span>
</span><span></span><span>#</span>include<span> </span><string><span>
</span>
<span></span>void returnWithReference(std::string& str, int& num) <span>{
</span><span>    str = </span><span>"Hello"</span><span>;
</span><span>    num = </span>42<span>;
</span>}

<span></span>int main() <span>{
</span><span>    </span><span>std</span><span>::</span><span>string</span><span> str;
</span><span>    </span><span>int</span><span> num;
</span>    returnWithReference(str, num);
<span>    </span><span>std</span><span>::</span><span>cout</span><span> << str << </span><span>", "</span><span> << num << </span><span>std</span><span>::</span><span>endl</span><span>; </span><span>// 输出: Hello, 42</span><span>
</span><span>    </span><span>return</span><span> </span>0<span>;
</span>}</code></pre></div></div></pre>


## 二、C++ 中返回多个值的四种方法

### 方法 1️⃣：通过**引用（Reference）或指针（Pointer）参数**

将变量作为引用传入函数，函数内部修改其值，实现“多返回”。

#### ✅ 优点：

* 无需额外头文件
* 性能高（无拷贝）

#### ❌ 缺点：

* 调用者必须提前创建变量
* 接口不清晰（调用者不知道哪些参数会被修改）

#### 📌 示例代码：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>#</span>include<span> </span><iostream><span>
</span><span></span><span>#</span>include<span> </span><string><span>
</span>
<span></span>void returnWithReference(std::string& str, int& num) <span>{
</span><span>    str = </span><span>"Hello"</span><span>;
</span><span>    num = </span>42<span>;
</span>}

<span></span>int main() <span>{
</span><span>    </span><span>std</span><span>::</span><span>string</span><span> str;
</span><span>    </span><span>int</span><span> num;
</span>    returnWithReference(str, num);
<span>    </span><span>std</span><span>::</span><span>cout</span><span> << str << </span><span>", "</span><span> << num << </span><span>std</span><span>::</span><span>endl</span><span>; </span><span>// 输出: Hello, 42</span><span>
</span><span>    </span><span>return</span><span> </span>0<span>;
</span>}</code></pre></div></div></pre>


### 方法 3️⃣：返回 `std::tuple` 或 `std::pair`

`std::tuple` 可以打包多个不同类型的数据；`std::pair` 是 `tuple` 的特例（两个元素）。

#### ✅ 优点：

* 支持不同类型
* 可直接返回

#### ❌ 缺点：

* 语法不直观（`std::get<0>(tuple)`）
* 无法通过名字访问成员，可读性差

#### 📌 示例代码：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>#</span>include<span> </span><iostream><span>
</span><span></span><span>#</span>include<span> </span><tuple><span>
</span><span></span><span>#</span>include<span> </span><string><span>
</span>
<span></span>std::tuple<std::string, int> returnWithTuple() <span>{
</span><span>    </span><span>return</span><span> </span><span>std</span><span>::make_tuple(</span><span>"Hello"</span><span>, </span>42<span>);
</span>}

<span></span>std::pair<std::string, int> returnWithPair() <span>{
</span><span>    </span><span>return</span><span> </span><span>std</span><span>::</span><span>make_pair</span><span>(</span><span>"Hello"</span><span>, </span>42<span>);
</span>}

<span></span>int main() <span>{
</span><span>    </span><span>auto</span><span> tupleResult = returnWithTuple();
</span><span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>std</span><span>::get<</span>0<span>>(tupleResult) << </span><span>", "</span><span> << </span><span>std</span><span>::get<</span>1<span>>(tupleResult) << </span><span>std</span><span>::</span><span>endl</span><span>;
</span>
<span>    </span><span>auto</span><span> pairResult = returnWithPair();
</span><span>    </span><span>std</span><span>::</span><span>cout</span><span> << pairResult.first << </span><span>", "</span><span> << pairResult.second << </span><span>std</span><span>::</span><span>endl</span><span>;
</span>
<span>    </span><span>return</span><span> </span>0<span>;
</span>}</code></pre></div></div></pre>


### 方法 4️⃣（推荐）：返回自定义 `struct`

创建一个结构体，包含所有要返回的字段。

#### ✅ 优点：

* 语义清晰，可读性强
* 成员有名字（`.str`, `.num`）
* 易于维护和扩展
* Cherno 推荐做法

#### ❌ 缺点：

* 需要额外定义结构体

#### 📌 示例代码：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>#</span>include<span> </span><iostream><span>
</span><span></span><span>#</span>include<span> </span><string><span>
</span>
<span></span>struct Result {<span>
</span><span>    </span><span>std</span><span>::</span><span>string</span><span> str;
</span><span>    </span><span>int</span><span> num;
</span>};

<span></span>Result returnWithStruct() <span>{
</span><span>    </span><span>return</span><span> {</span><span>"Hello"</span><span>, </span>42<span>}; </span><span>// 聚合初始化</span><span>
</span>}

<span></span>int main() <span>{
</span>    Result result = returnWithStruct();
<span>    </span><span>std</span><span>::</span><span>cout</span><span> << result.str << </span><span>", "</span><span> << result.num << </span><span>std</span><span>::</span><span>endl</span><span>; </span><span>// Hello, 42</span><span>
</span><span>    </span><span>return</span><span> </span>0<span>;
</span>}</code></pre></div></div></pre>


## 三、现代 C++ 增强：结构化绑定（C++17）

使用 **结构化绑定（Structured Bindings）**，可以更优雅地解构 `tuple`、`pair` 或 `struct`。

#### 示例（结合 `struct` 和结构化绑定）：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>#</span>include<span> </span><iostream><span>
</span><span></span><span>#</span>include<span> </span><string><span>
</span>
<span></span>struct Result {<span>
</span><span>    </span><span>std</span><span>::</span><span>string</span><span> str;
</span><span>    </span><span>int</span><span> num;
</span>};

<span></span>Result getData() <span>{
</span><span>    </span><span>return</span><span> {</span><span>"Hello"</span><span>, </span>42<span>};
</span>}

<span></span>int main() <span>{
</span><span>    </span><span>auto</span><span> [text, value] = getData(); </span><span>// 结构化绑定</span><span>
</span><span>    </span><span>std</span><span>::</span><span>cout</span><span> << text << </span><span>", "</span><span> << value << </span><span>std</span><span>::</span><span>endl</span><span>; </span><span>// Hello, 42</span><span>
</span><span>    </span><span>return</span><span> </span>0<span>;
</span>}</code></pre></div></div></pre>

> ✅ 需要编译器支持 C++17：`g++ -std=c++17 file.cpp`



## 四、完整可运行代码（包含所有方法）

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>#</span>include<span> </span><iostream><span>
</span><span></span><span>#</span>include<span> </span><string><span>
</span><span></span><span>#</span>include<span> </span><tuple><span>
</span><span></span><span>#</span>include<span> </span><array><span>
</span><span></span><span>#</span>include<span> </span><vector><span>
</span>
<span></span><span>// 方法1：引用返回</span><span>
</span><span></span>void returnWithReference(std::string& str, int& num) <span>{
</span><span>    str = </span><span>"Hello"</span><span>;
</span><span>    num = </span>42<span>;
</span>}

<span></span><span>// 方法2：array 和 vector</span><span>
</span><span></span>std::array<int, 2> returnWithArray() <span>{
</span><span>    </span><span>return</span><span> {</span>42<span>, </span>56<span>};
</span>}

<span></span>std::vector<int> returnWithVector() <span>{
</span><span>    </span><span>return</span><span> {</span>42<span>, </span>56<span>};
</span>}

<span></span><span>// 方法3：tuple 和 pair</span><span>
</span><span></span>std::tuple<std::string, int> returnWithTuple() <span>{
</span><span>    </span><span>return</span><span> </span><span>std</span><span>::make_tuple(</span><span>"Hello"</span><span>, </span>42<span>);
</span>}

<span></span>std::pair<std::string, int> returnWithPair() <span>{
</span><span>    </span><span>return</span><span> </span><span>std</span><span>::</span><span>make_pair</span><span>(</span><span>"Hello"</span><span>, </span>42<span>);
</span>}

<span></span><span>// 方法4：结构体（推荐）</span><span>
</span><span></span>struct Result {<span>
</span><span>    </span><span>std</span><span>::</span><span>string</span><span> str;
</span><span>    </span><span>int</span><span> num;
</span>};

<span></span>Result returnWithStruct() <span>{
</span><span>    </span><span>return</span><span> {</span><span>"Hello"</span><span>, </span>42<span>};
</span>}

<span></span>int main() <span>{
</span><span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"=== 方法1：引用 ==="</span><span> << </span><span>std</span><span>::</span><span>endl</span><span>;
</span><span>    </span><span>std</span><span>::</span><span>string</span><span> str;
</span><span>    </span><span>int</span><span> num;
</span>    returnWithReference(str, num);
<span>    </span><span>std</span><span>::</span><span>cout</span><span> << str << </span><span>", "</span><span> << num << </span><span>std</span><span>::</span><span>endl</span><span>;
</span>
<span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"\n=== 方法2：array/vector ==="</span><span> << </span><span>std</span><span>::</span><span>endl</span><span>;
</span><span>    </span><span>auto</span><span> arr = returnWithArray();
</span><span>    </span><span>auto</span><span> vec = returnWithVector();
</span><span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"Array: "</span><span> << arr[</span>0<span>] << </span><span>", "</span><span> << arr[</span>1<span>] << </span><span>std</span><span>::</span><span>endl</span><span>;
</span><span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"Vector: "</span><span> << vec[</span>0<span>] << </span><span>", "</span><span> << vec[</span>1<span>] << </span><span>std</span><span>::</span><span>endl</span><span>;
</span>
<span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"\n=== 方法3：tuple/pair ==="</span><span> << </span><span>std</span><span>::</span><span>endl</span><span>;
</span><span>    </span><span>auto</span><span> tupleResult = returnWithTuple();
</span><span>    </span><span>auto</span><span> pairResult = returnWithPair();
</span><span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"Tuple: "</span><span> << </span><span>std</span><span>::get<</span>0<span>>(tupleResult) << </span><span>", "</span><span> << </span><span>std</span><span>::get<</span>1<span>>(tupleResult) << </span><span>std</span><span>::</span><span>endl</span><span>;
</span><span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"Pair: "</span><span> << pairResult.first << </span><span>", "</span><span> << pairResult.second << </span><span>std</span><span>::</span><span>endl</span><span>;
</span>
<span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"\n=== 方法4：struct（推荐）==="</span><span> << </span><span>std</span><span>::</span><span>endl</span><span>;
</span>    Result result = returnWithStruct();
<span>    </span><span>std</span><span>::</span><span>cout</span><span> << result.str << </span><span>", "</span><span> << result.num << </span><span>std</span><span>::</span><span>endl</span><span>;
</span>
<span>    </span><span>// C++17 结构化绑定</span><span>
</span><span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"\n=== 结构化绑定（C++17）==="</span><span> << </span><span>std</span><span>::</span><span>endl</span><span>;
</span><span>    </span><span>auto</span><span> [text, value] = returnWithStruct();
</span><span>    </span><span>std</span><span>::</span><span>cout</span><span> << text << </span><span>", "</span><span> << value << </span><span>std</span><span>::</span><span>endl</span><span>;
</span>
<span>    </span><span>return</span><span> </span>0<span>;
</span>}</code></pre></div></div></pre>

---

## 📊 五、总结与推荐


| 方法                    | 适用场景           | 是否推荐           | 说明               |
| ----------------------- | ------------------ | ------------------ | ------------------ |
| **引用/指针**           | 简单场景，性能敏感 | ⚠️ 一般          | 接口不清晰         |
| **array/vector**        | 同类型数据         | ✅ 有限            | 仅用于同类型       |
| **tuple/pair**          | 临时组合数据       | ✅ 一般            | 语法不直观         |
| **struct + 结构化绑定** | **通用推荐**       | ✅✅✅**强烈推荐** | 语义清晰，可读性强 |

> 💡 **Cherno 的观点**：优先使用 `struct`，即使只为返回值创建一个结构体，也值得，因为它让代码更清晰、更易维护。
>
