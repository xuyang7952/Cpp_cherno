# C++中的指针的值存在哪里

## 简短回答

**是的，指针变量本身也需要内存来存储它指向的地址值**。这个内存可以位于：

* **栈上**（局部指针变量）
* **堆上**（动态分配的指针）
* **全局数据区**（全局/静态指针）

## 详细解释

### **1. 指针变量的内存位置**

<pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">#include <iostream>

int global_value = 100;           // 全局数据区
int* global_ptr = &global_value;   // global_ptr本身在全局数据区

int main() {
    int local_value = 200;        // 栈上
    int* stack_ptr = &local_value; // stack_ptr本身在栈上
  
    int* heap_ptr = new int(300);  // heap_ptr在栈上，但它指向堆内存
  
    // 验证指针本身的内存位置
    std::cout << "全局指针地址: " << &global_ptr << " (全局数据区)" << std::endl;
    std::cout << "栈上指针地址: " << &stack_ptr << " (栈上)" << std::endl;
    std::cout << "堆指针变量地址: " << &heap_ptr << " (栈上)" << std::endl;
  
    std::cout << "指针指向的地址: " << heap_ptr << " (堆内存)" << std::endl;
    std::cout << "指针指向的值: " << *heap_ptr << std::endl;
  
    delete heap_ptr;
    return 0;
}</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>

**输出示例**：

<pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-markdown">全局指针地址: 0x100008000 (全局数据区)
栈上指针地址: 0x7ffeefbff5c8 (栈上)
堆指针变量地址: 0x7ffeefbff5c0 (栈上)
指针指向的地址: 0x1007040c0 (堆内存)
指针指向的值: 300</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>

### **2. 指针的内存布局示意图**

<pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-markdown">栈内存 (Stack)
┌─────────────────┐
│ int local_value │ 地址: 0x7ffeefbff5d0
│    = 200        │
├─────────────────┤
│ int* stack_ptr  │ 地址: 0x7ffeefbff5c8  
│    = 0x7ffeefbff5d0 │ ← 存储着local_value的地址!
└─────────────────┘

堆内存 (Heap)
┌─────────────────┐
│     300         │ 地址: 0x1007040c0
└─────────────────┘

全局数据区
┌─────────────────┐
│ int* global_ptr │ 地址: 0x100008000
│    = 0x100008010 │
└─────────────────┘</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>

### **3. 指针的"双重身份"**

<pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">int main() {
    int value = 42;
    int* ptr = &value;
  
    // ptr本身是一个变量，需要内存存储地址值
    std::cout << "ptr变量的大小: " << sizeof(ptr) << " 字节" << std::endl;  // 通常是8字节(64位)
    std::cout << "ptr变量的地址: " << &ptr << std::endl;      // ptr本身在哪里
    std::cout << "ptr存储的值: " << ptr << std::endl;         // ptr指向哪里
    std::cout << "ptr指向的值: " << *ptr << std::endl;        // 解引用获取实际数据
  
    return 0;
}</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>

### **4. 指针链式存储（指针指向指针）**

<pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">#include <iostream>

int main() {
    int data = 999;
  
    int* ptr1 = &data;        // 一级指针：存储data的地址
    int** ptr2 = &ptr1;       // 二级指针：存储ptr1的地址  
    int*** ptr3 = &ptr2;      // 三级指针：存储ptr2的地址
  
    std::cout << "data的值: " << data << " 地址: " << &data << std::endl;
    std::cout << "ptr1的值: " << ptr1 << " ptr1自己的地址: " << &ptr1 << std::endl;
    std::cout << "ptr2的值: " << ptr2 << " ptr2自己的地址: " << &ptr2 << std::endl;
    std::cout << "ptr3的值: " << ptr3 << " ptr3自己的地址: " << &ptr3 << std::endl;
  
    // 通过多级指针访问data
    std::cout << "***ptr3 = " << ***ptr3 << std::endl;  // 输出: 999
  
    return 0;
}</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>

**内存关系**：

<pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-markdown">data    → 值: 999        (地址: 0x1000)
ptr1    → 值: 0x1000     (存储data地址)  
ptr2    → 值: 0x2000     (存储ptr1地址)
ptr3    → 值: 0x3000     (存储ptr2地址)</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>

### **5. 指针与寄存器优化**

虽然指针变量需要内存，但编译器会尽可能使用寄存器优化：

<pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">void process(int* ptr) {
    // 编译器可能将ptr保留在寄存器中，而不是反复访问内存
    for(int i = 0; i < 1000; i++) {
        *ptr += i;  // ptr可能一直在寄存器中
    }
}</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>

### **6. 实际内存占用验证**

<pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">#include <iostream>

struct Test {
    int* ptr1;
    int* ptr2;
    char ch;
    // 由于内存对齐，这个结构体大小可能让你惊讶
};

int main() {
    std::cout << "指针大小(64位系统): " << sizeof(int*) << " 字节" << std::endl;
    std::cout << "指针大小(32位系统): " << sizeof(void*)*8 << " 位" << std::endl;
  
    Test t;
    std::cout << "包含两个指针的结构体大小: " << sizeof(Test) << " 字节" << std::endl;
  
    // 演示指针数组的内存占用
    int* ptr_array[10];
    std::cout << "10个指针的数组大小: " << sizeof(ptr_array) << " 字节" << std::endl;
  
    return 0;
}</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>

---

## 🎯 **核心总结**

1. **指针本身是变量**：需要内存存储地址值
2. **存储位置灵活**：可以在栈、堆、全局数据区
3. **大小固定**：32位系统4字节，64位系统8字节
4. **编译器优化**：频繁使用的指针可能被保留在寄存器中
5. **内存层级**：指针形成"指向链"，每个环节都需要内存存储

**关键理解**：指针就像一张"地址纸条"，纸条本身需要地方存放（内存），纸条上写的是目标地址。这个"纸条"可以放在抽屉里（栈）、保险箱里（堆），或者贴在墙上（全局区）。


# 悬空指针


## 简短回答：

> **悬空指针是指：指针本身仍然存在，但它所指向的内存已经被释放了。**

换句话说：

* ✅ **内存被释放了**
* ❌ **指针本身没有被释放**（它还在，但指向了一块无效的内存）

---

## 🧠 详细解释

### 1. 什么是悬空指针？

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>int</span><span>* ptr = </span><span>new</span><span> </span><span>int</span><span>(</span>42<span>);  </span><span>// 在堆上分配内存，ptr 指向它</span><span>
</span><span></span><span>delete</span><span> ptr;              </span><span>// 内存被释放，但 ptr 变量仍然存在</span><span>
</span><span></span><span>// 此时 ptr 就是悬空指针！</span></code></pre></div></div></pre>

* `delete ptr;` 释放的是 `ptr` 所指向的**堆内存**
* `ptr` 这个指针变量本身仍然在栈上（或数据段），它的值（地址）没有变
* 但那块内存已经归还给操作系统或内存管理器
* 如果你再访问 `*ptr`，行为是**未定义的**（可能崩溃、可能读到垃圾数据）

---

## 🎯 图解过程

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">text</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>步骤 </span>1<span>：分配
</span>+---------------------+
|       堆 (Heap)      |
<span>|       </span>42<span>             |  ← 地址: </span>0x1234<span>
</span>+---------------------+
       ↑
       |
<span>    ptr → </span>0x1234<span>       ← ptr 存储的是 </span>0x1234<span>
</span>
<span>步骤 </span>2<span>：</span><span>delete</span><span> ptr
</span>+---------------------+
|       堆 (Heap)      |
|       ???            |  ← 内存已释放，内容可能被覆盖
+---------------------+
       ↑
       |
<span>    ptr → </span>0x1234<span>       ← ptr 的值没变！但它指向的内存已无效
</span>
→ ptr 成为悬空指针</code></pre></div></div></pre>

---

## 🔍 悬空指针的常见来源

### 1. `delete` 后未置空

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>int</span><span>* ptr = </span><span>new</span><span> </span><span>int</span><span>(</span>10<span>);
</span><span></span><span>delete</span><span> ptr;
</span><span>ptr = </span><span>nullptr</span><span>; </span><span>// 避免悬空指针</span><span>
</span><span></span><span>// 如果不赋 nullptr，ptr 就是悬空指针</span></code></pre></div></div></pre>

### 2. 指向栈变量的指针

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>int</span><span>* ptr;
</span>{
<span>    </span><span>int</span><span> x = </span>5<span>;
</span><span>    ptr = &x;  </span><span>// ptr 指向局部变量 x</span><span>
</span><span>} </span><span>// x 被销毁，内存释放</span><span>
</span><span></span><span>// ptr 现在是悬空指针！</span></code></pre></div></div></pre>

### 3. 返回局部变量的地址

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code>int* create() <span>{
</span><span>    </span><span>int</span><span> x = </span>5<span>;
</span><span>    </span><span>return</span><span> &x; </span><span>// 错误！返回栈变量地址</span><span>
</span><span>} </span><span>// x 被销毁</span><span>
</span><span></span><span>// 调用者拿到的是悬空指针</span></code></pre></div></div></pre>

---

## 🆚 悬空指针 vs 空指针 vs 野指针


| 类型                             | 定义                              | 是否危险          |
| -------------------------------- | --------------------------------- | ----------------- |
| **空指针（Null Pointer）**       | 指针值为`nullptr`，不指向任何内存 | ✅ 安全（可判断） |
| **悬空指针（Dangling Pointer）** | 指向的内存已被释放，但指针未置空  | ❌ 极其危险       |
| **野指针（Wild Pointer）**       | 未初始化的指针，指向随机地址      | ❌ 极其危险       |

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>int</span><span>* p1 = </span><span>nullptr</span><span>;     </span><span>// 空指针 → 安全</span><span>
</span><span></span><span>int</span><span>* p2 = </span><span>new</span><span> </span><span>int</span><span>(</span>5<span>);
</span><span></span><span>delete</span><span> p2;
</span><span></span><span>// p2 是悬空指针 → 危险！</span><span>
</span>
<span></span><span>int</span><span>* p3;               </span><span>// 野指针（未初始化） → 危险！</span></code></pre></div></div></pre>

---

## ✅ 如何避免悬空指针？

### 1. `delete` 后立即置空

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>delete</span><span> ptr;
</span><span>ptr = </span><span>nullptr</span><span>;</span></code></pre></div></div></pre>

### 2. 使用智能指针（推荐）

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>#</span>include<span> </span><memory><span>
</span><span></span><span>std</span><span>::</span><span>unique_ptr</span><span><</span><span>int</span><span>> ptr = </span><span>std</span><span>::make_unique<</span><span>int</span><span>>(</span>42<span>);
</span><span></span><span>// 离开作用域自动释放，不会悬空</span></code></pre></div></div></pre>

### 3. 不要返回局部变量的地址

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>// ❌ 错误</span><span>
</span><span></span>int* get() <span>{
</span><span>    </span><span>int</span><span> x = </span>5<span>;
</span><span>    </span><span>return</span><span> &x;
</span>}

<span></span><span>// ✅ 正确</span><span>
</span><span></span>int get() <span>{
</span><span>    </span><span>return</span><span> </span>5<span>; </span><span>// 返回值，不是地址</span><span>
</span>}</code></pre></div></div></pre>

### 4. 使用引用或值传递代替裸指针

---

## ✅ 总结


| 问题                                       | 回答                                                  |
| ------------------------------------------ | ----------------------------------------------------- |
| **悬空指针是内存释放了，还是指针释放了？** | ✅ **内存被释放了**，指针变量本身仍然存在             |
| **为什么危险？**                           | 访问它会导致未定义行为（崩溃、数据损坏）              |
| **如何识别？**                             | 无法在运行时直接检测，靠代码规范和工具（如 Valgrind） |
| **如何避免？**                             | `delete` 后置空、使用智能指针、避免返回局部变量地址   |

> 💬 **一句话记住**：
> “**悬空指针 = 指针还活着，但它指向的房子已经被拆了。**”
>
