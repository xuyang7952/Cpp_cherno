# C++中的类

C++ 中的**类（Class）** 是一种核心的面向对象编程机制，它允许你将数据（称为成员变量或属性）和操作这些数据的函数（称为成员函数或方法）组织成一个单一的、自包含的单元


### 一、基本概念

* **类的定义**：类是一种用户自定义的数据类型，用于将相关的变量和函数封装在一起，形成一个逻辑整体。

  * 示例：在游戏中，一个 `Player`类可以包含坐标 `x`、`y`、速度 `speed`等属性，以及移动方法 `Move()`。
* **对象与实例**：

  * 由类创建的变量称为**对象（Object）**。
  * 创建对象的过程称为**实例化（Instantiation）**。


### 二、访问控制

类中的成员默认是 **`private`（私有）**，即只能在类内部访问。若要在类外部（如 `main`函数）访问，需显式声明为 **`public`（公有）**：

<pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">class Player {
public: // 公有成员，可在外部访问
    int x, y;
    int speed;
private: // 私有成员，仅类内部可访问
    int health;
};</code></div></div></pre></div></pre>


### 三、方法（Method）

* 定义在类内部的函数称为**方法**，用于操作类的成员变量。
* 与传统全局函数相比，方法更简洁、易于维护，且直接关联到对象。

**对比示例：**

* 全局函数方式：

  <pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">void Move(Player& player, int xa, int ya) {
      player.x += xa * player.speed;
      player.y += ya * player.speed;
  }</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>
* 类方法方式：

  <pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">class Player {
  public:
      void Move(int xa, int ya) {
          x += xa * speed;
          y += ya * speed;
      }
  };</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>

  调用时更简洁：`player.Move(1, -1);`


### 四、优势总结

1. **封装性**：将数据和操作绑定在一起，减少代码冗余。
2. **可读性与维护性**：代码更清晰，易于理解和扩展。
3. **灵活性**：支持多种编程范式（面向对象、泛型、过程式等）。
4. **语法糖（Syntactic Sugar）**：虽可用C语言实现类似功能，但C++的类提供了更自然、高效的表达方式。


### 总结

C++ 中的类是面向对象编程的基石，通过**封装数据和方法**、**控制访问权限**，显著提升代码的组织性和可维护性。它既保留了C语言的灵活性，又提供了更高级的抽象机制，是构建大型应用程序的重要工具。

### 五、使用场景

* 适合管理复杂数据结构（如游戏角色、图形对象、数据库实体等）。
* 适用于需要高可复用性和模块化的项目。

# 类与结构体区别


### 核心结论

正如第一张图（Cherno）所述，C++中的 `class`和 `struct`**在功能上几乎是完全相同的**。它们唯一的**技术性区别**在于默认的成员访问控制权限。


### 一、唯一的技术区别：默认访问权限


| 类型         | 默认继承方式 | 成员默认访问权限 |
| ------------ | ------------ | ---------------- |
| **`class`**  | `private`    | `private`        |
| **`struct`** | `public`     | `public`         |

**代码示例说明（来自您的第一张图）：**

1. **使用 `struct`**：成员默认是 `public`，可以直接访问。

   <pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">struct Player {
       int x, y; // 默认public，外部可直接读写
       int speed;
   };

   int main() {
       Player p;
       p.x = 5; // ✅ 编译成功
   }</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>
2. **使用 `class`**：成员默认是 `private`，外部无法直接访问。

   <pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">class Player {
       int x, y; // 默认private，外部不可访问
       int speed;
   };

   int main() {
       Player p;
       p.x = 5; // ❌ 编译错误：无法访问私有成员
   }</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>

   *当然，你可以在 `class`里手动写上 `public:`来让成员变成公有，从而消除这个区别。*


### 二、约定俗成的使用惯例（重要！）

尽管技术上区别很小，但在C++社区中，为了代码的可读性和传达设计意图，形成了一些广泛接受的**编程风格（Programming Style）**。

#### 1. 使用 `struct`的场景（代表“纯数据”的聚合体）

* **目的**：主要用来表示一个被动的、仅包含数据的集合体。它可能包含一些简单的方法来操作这些数据，但通常不包含复杂的业务逻辑。
* **特性**：通常不包含或极少包含私有成员，不希望有复杂的继承层次（如第一张图Cherno的观点：“绝对不继承”）。
* **示例**：坐标、颜色、配置选项等。

  <pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">// 来自您的第二张图：一个典型的使用struct表示数据的例子
  struct Vec2 { // 表示一个2D向量/坐标点
      float x, y; // 数据是公有的，可以直接访问

      // 一个简单的方法，用于操作自身数据
      void Add(const Vec2& other) {
          x += other.x;
          y += other.y;
      }
  };</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>

#### 2. 使用 `class`的场景（代表“功能完整”的对象）

* **目的**：用于表示具有完整功能、复杂行为和内部状态的“对象”。它强调**封装（Encapsulation）**，即隐藏内部实现细节，只通过公共接口与外部交互。
* **特性**：通常包含私有成员变量和受保护的成员，会使用继承和多态等面向对象特性（如第二张图注释：“很多功能的类，可能继承的东西”）。
* **示例**：游戏中的玩家、文件流、数据库连接器等。

  <pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">class Player {
  private: // 内部状态被保护起来
      std::string name;
      int health;
      Vec2 position; // 可能包含上面定义的struct作为成员

  public:
      // 通过公共方法（接口）来操作对象
      void Move(const Vec2& direction);
      void TakeDamage(int amount);
      bool IsAlive() const;
      // ... 可能还会继承自某个基类，如 class Player : public Entity
  };</code></div></div></pre></div></pre>


### 总结与选择建议


| 方面         | `struct`                                  | `class`                             |
| ------------ | ----------------------------------------- | ----------------------------------- |
| **技术核心** | 默认`public`                              | 默认`private`                       |
| **设计意图** | **数据聚合** (Data Aggregation)           | **对象封装** (Object Encapsulation) |
| **常见用法** | 简单的数据容器，POD（Plain Old Data）类型 | 复杂的、有行为的对象，使用OOP特性   |
| **继承**     | 通常避免使用                              | 经常使用                            |
| **风格建议** | 当你需要一个“只有数据的结构”时          | 当你需要一个“具有功能的类”时      |

**如何选择？**

* 问自己一个问题：**我主要是在定义一个数据结构，还是在定义一个具有行为的对象？**

  * 如果主要是**数据**，成员变量希望默认是公开的，使用 `struct`。
  * 如果主要是**行为**（方法），需要隐藏内部数据并提供接口，使用 `class`。

遵循这些惯例可以让你的代码**意图更清晰**，更容易被其他程序员理解。这就像一种无声的文档，仅仅通过你使用的关键字就能传达出很多设计信息。


# C++中的静态


### C++ 中 `static`关键字的总结与说明

`static`关键字在C++中有两种主要用法，其含义和目的截然不同，取决于它被用于**类的外部**还是**类的内部**。


### 一、在类（或结构体）外部使用 `static`（文件作用域）

这是图片一和图片二重点讲解的内容。

#### 1. 核心作用：控制**链接属性 (Linkage)**

* 当一个变量或函数在全局或命名空间作用域被声明为 `static`时，它会获得**内部链接 (Internal Linkage)**。
* 这意味着这个符号（变量或函数）**只在定义它的编译单元（即同一个 `.cpp`或 `.obj`文件）内可见**。
* 链接器 (**Linker**) 在链接不同编译单元时，不会看到这个 `static`符号，因此它不会与其他编译单元中的同名符号发生冲突。

#### 2. 示例与问题解决（来自您的图片）

* **问题场景**：在两个不同的 `.cpp`文件中定义同名的全局变量 `int s_Variable`，链接时会报 **“LNK1169: 找到一个或多个多重定义的符号”** 错误。
* **解决方案**：

  1. **使用 `static`**：在其中一个文件中使用 `static int s_Variable = 5;`。这会将其链接属性限制在本文件内，从而避免冲突。
  2. **使用 `extern`（图片二）**：这是另一种解决方案。在其中一个文件（如 `Main.cpp`）中**声明**变量时使用 `extern`，表示“这个变量在另一个编译单元中定义”。

     * `Static.cpp`: `int s_Variable = 5;`// 实际的定义，具有外部链接
     * `Main.cpp`: `extern int s_Variable;`// 仅仅是声明，告诉编译器去其他地方找定义
     * `std::cout << s_Variable << std::endl;`// 输出 5

#### 3. 总结：类外 `static`的意义

* **主要目的**：封装文件内部的实现细节，避免全局符号污染和命名冲突。
* **最佳实践**：应该优先使用匿名命名空间 (`namespace { ... }`) 来实现同样的内部链接效果，这是现代C++更推荐的方式。但理解 `static`至关重要。


### 二、在类（或结构体）内部使用 `static`（类作用域）

这是图片一提及的另一个重要概念。

#### 1. 核心作用：表示“属于类”而不是“属于对象”

* **静态成员变量 (Static Member Variables)**:

  * 该变量由该类的**所有实例对象共享**。无论你创建多少个类的实例，静态成员变量在内存中**只有一份拷贝**。
  * 它存储在**静态存储区**（全局数据区），而不是在栈或堆上的对象内存中。
  * 必须在类外进行**单独的定义**（通常放在 `.cpp`文件中），以分配内存。
  * **示例**：可以用来统计已创建的对象数量、实现所有对象共享的配置等。
* **静态成员函数 (Static Member Functions)**:

  * 该函数**不属于任何单个对象**，因此它**没有 `this`指针**。
  * 它**只能直接访问类的静态成员变量和静态成员函数**，不能直接访问普通的非静态成员（因为非静态成员需要通过对象来访问）。
  * 调用方式：既可以通过对象调用 (`obj.StaticFunc()`)，也可以通过类名直接调用 (`ClassName::StaticFunc()`)。
  * **示例**：常用于创建工具函数、工厂方法等。

#### 2. 总结：类内 `static`的意义

* **主要目的**：实现数据或功能的共享，管理与类本身相关而非与实例相关的信息。


### 三、全局总结与对比表


| 特性               | 类外`static`(文件作用域)                           | 类内`static`(类作用域)     |
| ------------------ | -------------------------------------------------- | -------------------------- |
| **核心概念**       | **控制链接性** (Linkage)                           | **实现共享** (Sharing)     |
| **存储位置**       | 静态存储区                                         | 静态存储区                 |
| **生命周期**       | 整个程序运行期间                                   | 整个程序运行期间           |
| **关键区别**       | 限制符号的可见性到当前文件                         | 表示成员属于类而非对象实例 |
| **与`extern`关系** | `extern`是其互补关键字，用于**声明**外部链接的符号 | 与`extern`无关             |


### 四、关键要点

1. **双重角色**：`static`在C++中扮演着两个完全不同的角色，务必根据上下文区分。
2. **解决冲突**：在文件作用域，`static`（或匿名命名空间）和 `extern`是管理多个编译单元间全局符号、避免链接错误的关键工具。
3. **共享数据**：在类作用域，`static`用于创建被所有类实例共享的变量和函数。
4. **慎用全局变量**：正如您第二张图片底部所指出的，“**global很不好，容易产生bug**”。应尽量避免使用全局变量，如果必须使用，应通过 `static`或匿名命名空间限制其作用域，或者使用 `extern`进行谨慎的声明。

# C++类、结构体中的静态变量、静态方法


### 核心概念

在类或结构体中，使用 `static`关键字修饰的成员（变量或函数）具有一个核心特性：**它们不属于任何一个类的实例对象，而是属于类本身**。所有该类的对象共享同一份静态成员。



### 一、静态成员变量 (Static Member Variables)

#### 1. 特性（来自您的图片）

* **共享性**：正如第一张图所述：“这个类的所有实例中，这个变量只有一个实例”。无论创建多少个 `Entity`对象，`Entity::x`和 `Entity::y`在内存中都只有一份拷贝。
* **全局性**：其生命周期和作用域类似于全局变量，但它的名字被封装在类的作用域内，避免了命名冲突。第一张图将其描述为“就像这个类的global实例”。
* **访问方式**：

  * 可以通过类的**任何对象**来访问（如 `e.x = 2;`）。
  * **更推荐**通过**类名**直接访问（如 `Entity::x = 5;`），这清晰地表明了它的静态属性。

#### 2. 定义与声明（关键步骤）

这是第二张图和第三张图代码展示的重点，也是最容易出错的地方。

* **在类内部声明**：这只是在类中说明了该静态变量的存在，并**没有为其分配内存**。

  <pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">struct Entity {
      static int x, y; // 声明
  };</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>
* **在类外部定义**：**必须在类外的某个地方（通常是一个.cpp文件）单独定义一次**，以真正分配存储空间。这是链接器能找到该变量所必需的。

  <pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">int Entity::x; // 定义（可初始化，如 int Entity::x = 0;）
  int Entity::y; // 定义</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>

  *如果缺少定义，链接时将出现“undefined reference”错误。*


### 二、静态成员函数 (Static Member Functions)

#### 1. 特性（来自您的第三张图）

* **无 `this`指针**：第三张图的注释明确指出：“static method不能访问非静态变量。你在类里写的每个非静态方法都会获得当前的类实例作为参数(this指针)”。静态成员函数不与任何特定对象绑定，因此它内部**不能直接访问**普通的非静态成员变量和函数（因为它们需要通过 `this`指针来访问）。
* **访问权限**：静态成员函数**只能直接访问**其他的静态成员（变量或函数）。
* **调用方式**：

  * 可以通过类名调用：`ClassName::StaticFunction()`
  * 也可以通过对象调用：`object.StaticFunction()`（但一般不推荐，容易误导）

#### 2. 如何访问非静态成员？

正如第三张图的解决方案所示：如果需要让静态函数操作对象的数据，必须**将对象作为参数传递进去**。

<pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">static void Print(const Entity& e) // 接收一个对象的引用作为参数
{
    // 现在可以通过传入的对象e来访问其非静态成员x和y
    std::cout << e.x << "," << e.y << std::endl;
}</code></div></div></pre></div></pre>


### 三、总结对比表


| 特性           | 静态成员 (Static)                     | 非静态成员 (Non-Static)             |
| -------------- | ------------------------------------- | ----------------------------------- |
| **归属**       | 属于**类本身**                        | 属于类的**每个实例对象**            |
| **内存**       | 只有一份拷贝，所有对象共享            | 每个对象都有自己的一份拷贝          |
| **生命周期**   | 程序运行期间一直存在                  | 随着对象的创建而创建，销毁而销毁    |
| **访问方式**   | `ClassName::Member`或 `obj.Member`    | `obj.Member`                        |
| **成员函数内** | 无法访问非静态成员，**无 `this`指针** | 可以访问所有成员，**有 `this`指针** |


### 四、使用场景与最佳实践

1. **静态变量的用途**：

   * 存储所有对象共享的配置或数据（如计数器、常量、全局状态）。
2. **静态函数的用途**：

   * 创建**工具函数**或**工厂方法**，这些函数与类相关，但不需要先创建对象就能使用。
   * 操作静态成员变量。
3. **最佳实践**：

   * **访问静态成员时，优先使用 `类名::`语法**，使代码意图更清晰。
   * **不要忘记在类外定义静态成员变量**。
   * 明确静态函数无法直接访问非静态成员，需要时通过传递对象参数来实现。
