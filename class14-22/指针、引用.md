# 指针

#### 1. 指针的本质 (What is a pointer?)

* **定义**：指针本质上是一个**整数**，其值是另一个变量的**内存地址**。它本身不存储数据，而是指向存储数据的内存位置。
* **比喻**：将电脑内存想象成一条长长的街道，每个字节（byte）是街道上的一栋房子，而内存地址就是房子的门牌号。指针就是这个门牌号，告诉你数据（“货物”）具体存放在哪个“房子”里。
* **类型无关性**：所有类型的指针（`int*`, `char*`, `double*`等）在本质上都是存储地址的整数。指针的类型（如 `int*`）主要作用是**告诉编译器如何解释该地址指向的数据**，以及指针算术运算的步长（如 `int*`加1则地址增加4字节）。它本身并不改变指针是一个地址的事实。
* **无类型指针**：`void*`是一种特殊的指针类型，它没有关联的数据类型。这意味着你不能直接对其进行解引用，必须将其转换为具体的类型后才能使用。它通常用于处理未知类型的内存块。

#### 2. 指针的声明与初始化

* 声明一个指针需要在其类型后加上星号 `*`，例如 `int* ptr;`。
* **初始化**：指针应始终被初始化，以避免成为“野指针”（指向随机内存地址）。有三种常见方式将其初始化为“无效”状态：

  <pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">void* ptr = 0;       // 使用字面值0
  void* ptr = NULL;    // 使用NULL宏（通常是0的别名）
  void* ptr = nullptr; // (C++11引入) 推荐使用，类型安全</code></div></div></pre></div></pre>

#### 3. 使用指针：解引用与读写

* **解引用 (Dereferencing)**：通过在指针变量前使用星号 `*`操作符，可以**访问或修改**该指针所指向地址的数据。

  <pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">int var = 8;
  int* ptr = &var; // ptr 存储了变量var的地址
  *ptr = 10;       // 通过ptr解引用，将var的值改为10
  std::cout << *ptr; // 输出10，读取var的值</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>
* **取址操作符 (&)**：使用 `&`操作符可以获取一个变量的内存地址。

  <pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">int var = 8;
  int* ptr = &var; // 将变量var的地址赋值给指针ptr</code></div></div></pre></div></pre>

#### 4. 动态内存管理

* **分配内存**：使用 `new`关键字在**堆（Heap）** 上动态分配内存。堆上的内存生命周期由程序员手动控制。

  <pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">char* buffer = new char[8]; // 动态分配一个8字节的字符数组</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>
* **释放内存**：使用 `delete`（对于单个对象）或 `delete[]`（对于数组）来释放由 `new`分配的内存，防止内存泄漏。

  <pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">delete[] buffer; // 释放之前分配的数组内存</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>
* **memset**：用于将一段内存块的所有字节设置为特定值。常用于初始化（如清零）。

  <pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">memset(buffer, 0, 8); // 将buffer指向的8个字节的内存全部设置为0</code></div></div></pre></div></pre>

#### 5. 多级指针与内存布局

* **指针的指针**：可以定义指向指针的指针（如 `char** ptr`），用于更复杂的数据结构或间接寻址。
* **大小与字节序**：

  * 在**32位程序**中，指针的大小恒为**4字节**；在64位程序中，则为8字节。
  * **字节序 (Endianness)**：大多数个人计算机采用**小端字节序**，即数据的低位字节存储在低内存地址，高位字节存储在高内存地址。在查看内存时需要注意这一点。

### 核心思想总结

指针并不神秘，它本质上就是**内存地址的数字表示**。理解C++指针的关键在于：

1. 认识到它就是一个存储地址的整数。
2. 理解指针的**类型**主要是一种编译期辅助工具，用于数据解读和运算。
3. 掌握通过 `*`**解引用**来访问和操作目标数据。
4. 牢记**动态内存**必须手动申请 (`new`) 和释放 (`delete`)，否则会造成内存泄漏。

# 指针类型

### 1. 指向第一个字节的位置

您的理解“指向第一个字节的位置”是核心关键。**指针的值，就是它所指向的那个数据在内存中的起始地址（即第一个字节的地址）**。

图片1中的比喻和图片2中的内存查看器都明确展示了这一点：

* 图片1：将内存比作街道，字节比作房子，指针就是房子的“门牌号”（地址）。这个门牌号指向的是特定房子的**位置**。
* 图片2：代码中 `int var = 8;`，通过 `&var`获取到的地址 `0x0135FD6C`就是变量 `var`在内存中**起始的第一个字节的地址**。在Memory窗口中查看这个地址，可以看到数据 `08 00 00 00`就存储在这里。

### 2. 不同类型指针的占用大小

您的理解“不同类型的指针，占用内存大小不同”是**一个常见的误解，但根据标准，实际上是不正确的**。

图片1和图片4都明确指出了：

* **所有数据指针（`int*`, `char*`, `double*`等）在同一个程序中的大小是相同的**。
* 其大小**不取决于它指向什么类型的数据**，而**取决于程序的编译架构**：

  * 在 **32位 (x86) 程序**中，任何数据指针的大小都是 **4字节**（32位）。
  * 在 **64位 (x64) 程序**中，任何数据指针的大小都是 **8字节**（64位）。

图片4中的调试信息 `ptr`的地址是 `0x003df80c`，并且明确指出“我们知道这个指针将是4字节，因为我们运行的是32位程序”，完美地证实了这一点。`char** ptr`（一个指向指针的指针）本身也只是一个4字节的变量，它存储着另一个地址。

### 3. 类型的作用

既然所有指针的大小都一样，都只存储一个起始地址，那么为什么还需要不同的类型（如 `int*`和 `char*`）呢？

图片1和图片2的代码示例解释了原因：**指针的类型告诉了编译器如何“解读”该地址开始的内存数据**。

* **读写操作（解引用）**：当您写 `*ptr = 10;`时，编译器需要知道从 `ptr`指向的地址开始，要写入多少字节的数据。一个 `int*`会让编译器写入4个字节（通常），而一个 `char*`只会写入1个字节。
* **指针算术运算**：当您对指针进行加减运算时（如 `ptr + 1`），指针的类型决定了跳跃的步长。`char* ptr + 1`会让地址值增加1个字节，而 `int* ptr + 1`会让地址值增加4个字节（假设 `int`为4字节）。

这就是为什么在图片2中，即使将 `int`变量的地址强制转换为 `double*`类型，指针依然能正确找到内存的起始位置，但如果对其进行解引用，则会按照 `double`的类型（通常8字节）去解释那里的数据，从而得到毫无意义的错误数值。

### 总结

您的理解可以精确地总结为：

**指针是一个存储内存地址的整数。这个地址永远是它所指向的数据在内存中的第一个字节的地址。在相同的程序架构（32位或64位）下，所有数据指针本身占用的内存大小是相同的。指针的类型并不改变其大小和本质，它的作用是告诉编译器如何正确地访问和操作从该起始地址开始的内存数据。**

# 指针基本类型

## 一、直接答案：

> ❌ **C++ 中的指针不是类（class），它是语言内置的（built-in）基本类型，是直接由硬件和编译器支持的底层机制。**

指针的本质是：**内存地址的抽象表示**。

---

## ✅ 二、指针的本质：内存地址

### 1. 内存是什么？

* 计算机的内存（RAM）可以看作是一个巨大的**字节数组**。
* 每个字节都有一个唯一的编号，叫做 **地址（address）**。
* 地址通常是十六进制数，比如 `0x7fff12345678`。

### 2. 指针是什么？

* 指针就是一个**存储内存地址的变量**。
* 它的值是某个对象（变量、数组、函数等）在内存中的起始地址。

<pre><div class="tongyi-design-highlighter global-dark-theme"><span class="tongyi-design-highlighter-header"><span class="tongyi-design-highlighter-lang">cpp</span><div class="tongyi-design-highlighter-right-actions"><div class="tongyi-design-highlighter-theme-changer"><div class="tongyi-design-highlighter-theme-changer-btn"><span>深色版本</span><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#tongyi-down-line"></use></svg></span></div></div><svg width="12" height="12" viewBox="0 0 11.199999809265137 11.199999809265137" class="cursor-pointer flex items-center tongyi-design-highlighter-copy-btn"><g><path d="M11.2,1.6C11.2,0.716344,10.4837,0,9.6,0L4.8,0C3.91634,0,3.2,0.716344,3.2,1.6L4.16,1.6Q4.16,1.3349,4.34745,1.14745Q4.5349,0.96,4.8,0.96L9.6,0.96Q9.8651,0.96,10.0525,1.14745Q10.24,1.3349,10.24,1.6L10.24,6.4Q10.24,6.6651,10.0525,6.85255Q9.8651,7.04,9.6,7.04L9.6,8C10.4837,8,11.2,7.28366,11.2,6.4L11.2,1.6ZM0,4L0,9.6C0,10.4837,0.716344,11.2,1.6,11.2L7.2,11.2C8.08366,11.2,8.8,10.4837,8.8,9.6L8.8,4C8.8,3.11634,8.08366,2.4,7.2,2.4L1.6,2.4C0.716344,2.4,0,3.11634,0,4ZM1.14745,10.0525Q0.96,9.8651,0.96,9.6L0.96,4Q0.96,3.7349,1.14745,3.54745Q1.3349,3.36,1.6,3.36L7.2,3.36Q7.4651,3.36,7.65255,3.54745Q7.84,3.7349,7.84,4L7.84,9.6Q7.84,9.8651,7.65255,10.0525Q7.4651,10.24,7.2,10.24L1.6,10.24Q1.3349,10.24,1.14745,10.0525Z"></path></g></svg></div></span><div><pre><code><span>int</span><span> x = </span>10<span>;
</span><span></span><span>int</span><span>* p = &x;  </span><span>// p 是一个指针，存储 x 的地址</span></code></pre></div></div></pre>

此时：

* `p` 的值是 `&x`（比如 `0x7fff12345678`）
* `p` 本身也占用内存（比如 8 字节）

## 三、指针在内存中是如何表示的？


| 变量 | 值                     | 内存地址      |
| ---- | ---------------------- | ------------- |
| `x`  | 10                     | `0x7fff...78` |
| `p`  | `0x7fff...78`（即 &x） | `0x7fff...80` |

* `p` 是一个变量，它自己的地址是 `0x7fff...80`
* `p` 存储的值是 `x` 的地址 `0x7fff...78`
* 通过 `*p` 可以访问 `x` 的值（解引用）

<pre><div class="tongyi-design-highlighter global-dark-theme"><span class="tongyi-design-highlighter-header"><span class="tongyi-design-highlighter-lang"></span><div class="tongyi-design-highlighter-right-actions"><div class="tongyi-design-highlighter-theme-changer"><div class="tongyi-design-highlighter-theme-changer-btn"><span>深色版本</span><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#tongyi-down-line"></use></svg></span></div></div><svg width="12" height="12" viewBox="0 0 11.199999809265137 11.199999809265137" class="cursor-pointer flex items-center tongyi-design-highlighter-copy-btn"><g><path d="M11.2,1.6C11.2,0.716344,10.4837,0,9.6,0L4.8,0C3.91634,0,3.2,0.716344,3.2,1.6L4.16,1.6Q4.16,1.3349,4.34745,1.14745Q4.5349,0.96,4.8,0.96L9.6,0.96Q9.8651,0.96,10.0525,1.14745Q10.24,1.3349,10.24,1.6L10.24,6.4Q10.24,6.6651,10.0525,6.85255Q9.8651,7.04,9.6,7.04L9.6,8C10.4837,8,11.2,7.28366,11.2,6.4L11.2,1.6ZM0,4L0,9.6C0,10.4837,0.716344,11.2,1.6,11.2L7.2,11.2C8.08366,11.2,8.8,10.4837,8.8,9.6L8.8,4C8.8,3.11634,8.08366,2.4,7.2,2.4L1.6,2.4C0.716344,2.4,0,3.11634,0,4ZM1.14745,10.0525Q0.96,9.8651,0.96,9.6L0.96,4Q0.96,3.7349,1.14745,3.54745Q1.3349,3.36,1.6,3.36L7.2,3.36Q7.4651,3.36,7.65255,3.54745Q7.84,3.7349,7.84,4L7.84,9.6Q7.84,9.8651,7.65255,10.0525Q7.4651,10.24,7.2,10.24L1.6,10.24Q1.3349,10.24,1.14745,10.0525Z"></path></g></svg></div></span><div><pre><code><span>p (地址 0x80) → [0x78] ───┐
</span>                          ↓
x (地址 0x78) → [10] ←───┘</code></pre></div></div></pre>

👉 指针 `p` 的值是地址，`*p` 是那个地址上的数据。

---

## ✅ 四、指针不是类，而是“基本类型”

C++ 中的指针类型是**语言原生支持的**，就像 `int`、`char` 一样。

<pre><div class="tongyi-design-highlighter global-dark-theme"><span class="tongyi-design-highlighter-header"><span class="tongyi-design-highlighter-lang">cpp</span><div class="tongyi-design-highlighter-right-actions"><div class="tongyi-design-highlighter-theme-changer"><div class="tongyi-design-highlighter-theme-changer-btn"><span>深色版本</span><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#tongyi-down-line"></use></svg></span></div></div><svg width="12" height="12" viewBox="0 0 11.199999809265137 11.199999809265137" class="cursor-pointer flex items-center tongyi-design-highlighter-copy-btn"><g><path d="M11.2,1.6C11.2,0.716344,10.4837,0,9.6,0L4.8,0C3.91634,0,3.2,0.716344,3.2,1.6L4.16,1.6Q4.16,1.3349,4.34745,1.14745Q4.5349,0.96,4.8,0.96L9.6,0.96Q9.8651,0.96,10.0525,1.14745Q10.24,1.3349,10.24,1.6L10.24,6.4Q10.24,6.6651,10.0525,6.85255Q9.8651,7.04,9.6,7.04L9.6,8C10.4837,8,11.2,7.28366,11.2,6.4L11.2,1.6ZM0,4L0,9.6C0,10.4837,0.716344,11.2,1.6,11.2L7.2,11.2C8.08366,11.2,8.8,10.4837,8.8,9.6L8.8,4C8.8,3.11634,8.08366,2.4,7.2,2.4L1.6,2.4C0.716344,2.4,0,3.11634,0,4ZM1.14745,10.0525Q0.96,9.8651,0.96,9.6L0.96,4Q0.96,3.7349,1.14745,3.54745Q1.3349,3.36,1.6,3.36L7.2,3.36Q7.4651,3.36,7.65255,3.54745Q7.84,3.7349,7.84,4L7.84,9.6Q7.84,9.8651,7.65255,10.0525Q7.4651,10.24,7.2,10.24L1.6,10.24Q1.3349,10.24,1.14745,10.0525Z"></path></g></svg></div></span><div><pre><code><span>int</span><span>*      </span><span>// 指向 int 的指针</span><span>
</span><span></span><span>double</span><span>*   </span><span>// 指向 double 的指针</span><span>
</span><span></span><span>void</span><span>*     </span><span>// 通用指针（指向未知类型）</span></code></pre></div></div></pre>

这些类型由编译器直接支持，不需要定义类。

## 五、那有没有“像指针的类”？

✅ **有！C++ 标准库中有一些“智能指针”是类，它们模拟指针行为，但增加了自动内存管理。**

### 1. `std::shared_ptr<T>`

* 类模板，管理动态对象的生命周期。
* 使用引用计数，自动释放内存。

<pre><div class="tongyi-design-highlighter global-dark-theme"><span class="tongyi-design-highlighter-header"><span class="tongyi-design-highlighter-lang">cpp</span><div class="tongyi-design-highlighter-right-actions"><div class="tongyi-design-highlighter-theme-changer"><div class="tongyi-design-highlighter-theme-changer-btn"><span>深色版本</span><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#tongyi-down-line"></use></svg></span></div></div><svg width="12" height="12" viewBox="0 0 11.199999809265137 11.199999809265137" class="cursor-pointer flex items-center tongyi-design-highlighter-copy-btn"><g><path d="M11.2,1.6C11.2,0.716344,10.4837,0,9.6,0L4.8,0C3.91634,0,3.2,0.716344,3.2,1.6L4.16,1.6Q4.16,1.3349,4.34745,1.14745Q4.5349,0.96,4.8,0.96L9.6,0.96Q9.8651,0.96,10.0525,1.14745Q10.24,1.3349,10.24,1.6L10.24,6.4Q10.24,6.6651,10.0525,6.85255Q9.8651,7.04,9.6,7.04L9.6,8C10.4837,8,11.2,7.28366,11.2,6.4L11.2,1.6ZM0,4L0,9.6C0,10.4837,0.716344,11.2,1.6,11.2L7.2,11.2C8.08366,11.2,8.8,10.4837,8.8,9.6L8.8,4C8.8,3.11634,8.08366,2.4,7.2,2.4L1.6,2.4C0.716344,2.4,0,3.11634,0,4ZM1.14745,10.0525Q0.96,9.8651,0.96,9.6L0.96,4Q0.96,3.7349,1.14745,3.54745Q1.3349,3.36,1.6,3.36L7.2,3.36Q7.4651,3.36,7.65255,3.54745Q7.84,3.7349,7.84,4L7.84,9.6Q7.84,9.8651,7.65255,10.0525Q7.4651,10.24,7.2,10.24L1.6,10.24Q1.3349,10.24,1.14745,10.0525Z"></path></g></svg></div></span><div><pre><code><span>#</span>include<span> </span><memory><span>
</span><span>std::shared_ptr<</span><span>int</span><span>> p = std::make_shared<</span><span>int</span><span>>(</span>10<span>);</span></code></pre></div></div></pre>

* `p` 是一个对象（类实例），不是内置指针。
* 但它重载了 `*` 和 `->`，用起来像指针。

### 2. `std::unique_ptr<T>`

* 独占所有权的智能指针。

### 3. 迭代器（Iterators）

* STL 中的迭代器（如 `vector<int>::iterator`）也像指针。
* 它们是类，但重载了 `*`、`++` 等操作符。

---

## ✅ 六、指针 vs 智能指针（类）对比


| 特性                 | C++ 原生指针         | 智能指针（如`shared_ptr`） |
| -------------------- | -------------------- | -------------------------- |
| 类型                 | 内置类型             | 类模板                     |
| 是否需要手动`delete` | 是                   | 否（自动释放）             |
| 空值                 | `nullptr`            | `nullptr`                  |
| 解引用               | `*ptr`               | `*ptr`（重载）             |
| 成员访问             | `ptr->member`        | `ptr->member`（重载）      |
| 内存安全             | 低（易出错）         | 高（RAII）                 |
| 性能                 | 极高（直接硬件映射） | 略低（有少量开销）         |

---

## ✅ 七、指针的底层实现：编译器 + 硬件

指针的实现依赖于：

1. **编译器**：
   * 将 `&x` 编译成“取变量地址”的指令。
   * 将 `*p` 编译成“从 p 的值作为地址读取数据”。
2. **CPU 架构**：
   * 提供寄存器（如 `rax`, `rbx`）来存储地址和数据。
   * 提供寻址模式（如直接寻址、间接寻址）。
3. **操作系统**：
   * 提供虚拟内存机制，让程序看到连续的地址空间。

## 八、总结


| 问题                   | 答案                                                                                      |
| ---------------------- | ----------------------------------------------------------------------------------------- |
| **C++ 指针是类吗？**   | ❌ 不是，它是**内置的基本类型**。                                                         |
| **指针的本质是什么？** | ✅ 是**内存地址的变量**，直接映射到硬件。                                                 |
| **指针如何实现？**     | ✅ 由**编译器直接翻译成汇编指令**，操作 CPU 寄存器和内存。                                |
| **有没有像指针的类？** | ✅ 有，如`std::shared_ptr`、`std::unique_ptr`，它们是**智能指针类**，提供安全的指针语义。 |

---

### 🎯 最终比喻：

* **C++ 原生指针**：就像一把真实的钥匙，能直接打开内存的门，但用不好会闯祸（野指针、内存泄漏）。
* **智能指针（类）**：就像一把智能锁 + 自动门禁系统，安全但稍慢。

---

所以，记住一句话：

> **指针不是类，它是 C++ 通往内存的“后门”，而智能指针是“安全通道”。**

# 指针与类型大小

**指针本身并不存储对象的大小，而是它的“类型”告诉编译器这个信息。**

## 一、指针的本质：地址 + 类型

一个指针由两部分组成：


| 部分             | 说明                                             |
| ---------------- | ------------------------------------------------ |
| **值（value）**  | 存储的是内存地址（4字节或8字节）                 |
| **类型（type）** | 告诉编译器：“这个地址开始，我指向的是什么类型” |

<pre><div class="tongyi-design-highlighter global-dark-theme"><span class="tongyi-design-highlighter-header"><span class="tongyi-design-highlighter-lang">cpp</span><div class="tongyi-design-highlighter-right-actions"><div class="tongyi-design-highlighter-theme-changer"><div class="tongyi-design-highlighter-theme-changer-btn"><span>深色版本</span><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#tongyi-down-line"></use></svg></span></div></div><svg width="12" height="12" viewBox="0 0 11.199999809265137 11.199999809265137" class="cursor-pointer flex items-center tongyi-design-highlighter-copy-btn"><g><path d="M11.2,1.6C11.2,0.716344,10.4837,0,9.6,0L4.8,0C3.91634,0,3.2,0.716344,3.2,1.6L4.16,1.6Q4.16,1.3349,4.34745,1.14745Q4.5349,0.96,4.8,0.96L9.6,0.96Q9.8651,0.96,10.0525,1.14745Q10.24,1.3349,10.24,1.6L10.24,6.4Q10.24,6.6651,10.0525,6.85255Q9.8651,7.04,9.6,7.04L9.6,8C10.4837,8,11.2,7.28366,11.2,6.4L11.2,1.6ZM0,4L0,9.6C0,10.4837,0.716344,11.2,1.6,11.2L7.2,11.2C8.08366,11.2,8.8,10.4837,8.8,9.6L8.8,4C8.8,3.11634,8.08366,2.4,7.2,2.4L1.6,2.4C0.716344,2.4,0,3.11634,0,4ZM1.14745,10.0525Q0.96,9.8651,0.96,9.6L0.96,4Q0.96,3.7349,1.14745,3.54745Q1.3349,3.36,1.6,3.36L7.2,3.36Q7.4651,3.36,7.65255,3.54745Q7.84,3.7349,7.84,4L7.84,9.6Q7.84,9.8651,7.65255,10.0525Q7.4651,10.24,7.2,10.24L1.6,10.24Q1.3349,10.24,1.14745,10.0525Z"></path></g></svg></div></span><div><pre><code><span>int</span><span>* p;     </span><span>// p 是“指向 int 的指针”</span><span>
</span><span></span><span>long</span><span>* q;    </span><span>// q 是“指向 long 的指针”</span></code></pre></div></div></pre>

* `p` 和 `q` 都是 8 字节（64位系统），存储的都是地址。
* 但它们的**类型不同**，所以编译器知道：
  * `p` 指向的是 **4 字节**的数据（`int`）
  * `q` 指向的是 **8 字节**的数据（`long`）

---

## ✅ 二、类型决定了“解引用”和“指针运算”的行为

### 1. 解引用：`*p`

<pre><div class="tongyi-design-highlighter global-dark-theme"><span class="tongyi-design-highlighter-header"><span class="tongyi-design-highlighter-lang">cpp</span><div class="tongyi-design-highlighter-right-actions"><div class="tongyi-design-highlighter-theme-changer"><div class="tongyi-design-highlighter-theme-changer-btn"><span>深色版本</span><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#tongyi-down-line"></use></svg></span></div></div><svg width="12" height="12" viewBox="0 0 11.199999809265137 11.199999809265137" class="cursor-pointer flex items-center tongyi-design-highlighter-copy-btn"><g><path d="M11.2,1.6C11.2,0.716344,10.4837,0,9.6,0L4.8,0C3.91634,0,3.2,0.716344,3.2,1.6L4.16,1.6Q4.16,1.3349,4.34745,1.14745Q4.5349,0.96,4.8,0.96L9.6,0.96Q9.8651,0.96,10.0525,1.14745Q10.24,1.3349,10.24,1.6L10.24,6.4Q10.24,6.6651,10.0525,6.85255Q9.8651,7.04,9.6,7.04L9.6,8C10.4837,8,11.2,7.28366,11.2,6.4L11.2,1.6ZM0,4L0,9.6C0,10.4837,0.716344,11.2,1.6,11.2L7.2,11.2C8.08366,11.2,8.8,10.4837,8.8,9.6L8.8,4C8.8,3.11634,8.08366,2.4,7.2,2.4L1.6,2.4C0.716344,2.4,0,3.11634,0,4ZM1.14745,10.0525Q0.96,9.8651,0.96,9.6L0.96,4Q0.96,3.7349,1.14745,3.54745Q1.3349,3.36,1.6,3.36L7.2,3.36Q7.4651,3.36,7.65255,3.54745Q7.84,3.7349,7.84,4L7.84,9.6Q7.84,9.8651,7.65255,10.0525Q7.4651,10.24,7.2,10.24L1.6,10.24Q1.3349,10.24,1.14745,10.0525Z"></path></g></svg></div></span><div><pre><code><span>int</span><span> x = </span>10<span>;
</span><span></span><span>int</span><span>* p = &x;
</span><span></span><span>int</span><span> value = *p;  </span><span>// 读取从 p 指向地址开始的 4 个字节，解释为 int</span></code></pre></div></div></pre>

* 编译器看到 `p` 是 `int*`，就知道要从 `p` 的地址开始：
  * 读取 **4 个字节**
  * 按照 `int` 的方式解释它们

👉 类型告诉编译器“读多大、怎么解释”。

---

### 2. 指针运算：`p + 1`

<pre><div class="tongyi-design-highlighter global-dark-theme"><span class="tongyi-design-highlighter-header"><span class="tongyi-design-highlighter-lang">cpp</span><div class="tongyi-design-highlighter-right-actions"><div class="tongyi-design-highlighter-theme-changer"><div class="tongyi-design-highlighter-theme-changer-btn"><span>深色版本</span><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#tongyi-down-line"></use></svg></span></div></div><svg width="12" height="12" viewBox="0 0 11.199999809265137 11.199999809265137" class="cursor-pointer flex items-center tongyi-design-highlighter-copy-btn"><g><path d="M11.2,1.6C11.2,0.716344,10.4837,0,9.6,0L4.8,0C3.91634,0,3.2,0.716344,3.2,1.6L4.16,1.6Q4.16,1.3349,4.34745,1.14745Q4.5349,0.96,4.8,0.96L9.6,0.96Q9.8651,0.96,10.0525,1.14745Q10.24,1.3349,10.24,1.6L10.24,6.4Q10.24,6.6651,10.0525,6.85255Q9.8651,7.04,9.6,7.04L9.6,8C10.4837,8,11.2,7.28366,11.2,6.4L11.2,1.6ZM0,4L0,9.6C0,10.4837,0.716344,11.2,1.6,11.2L7.2,11.2C8.08366,11.2,8.8,10.4837,8.8,9.6L8.8,4C8.8,3.11634,8.08366,2.4,7.2,2.4L1.6,2.4C0.716344,2.4,0,3.11634,0,4ZM1.14745,10.0525Q0.96,9.8651,0.96,9.6L0.96,4Q0.96,3.7349,1.14745,3.54745Q1.3349,3.36,1.6,3.36L7.2,3.36Q7.4651,3.36,7.65255,3.54745Q7.84,3.7349,7.84,4L7.84,9.6Q7.84,9.8651,7.65255,10.0525Q7.4651,10.24,7.2,10.24L1.6,10.24Q1.3349,10.24,1.14745,10.0525Z"></path></g></svg></div></span><div><pre><code><span>int</span><span> arr[</span>3<span>] = {</span>1<span>, </span>2<span>, </span>3<span>};
</span><span></span><span>int</span><span>* p = arr;  </span><span>// p 指向 arr[0]</span><span>
</span>
<span>p++;           </span><span>// p 现在指向 arr[1]</span></code></pre></div></div></pre>

* `p++` 不是地址 +1，而是地址 + `sizeof(int)`
* 因为 `p` 是 `int*`，所以 `p + 1` = `p + 4`（假设 `int` 4字节）

<pre><div class="tongyi-design-highlighter global-dark-theme"><span class="tongyi-design-highlighter-header"><span class="tongyi-design-highlighter-lang">cpp</span><div class="tongyi-design-highlighter-right-actions"><div class="tongyi-design-highlighter-theme-changer"><div class="tongyi-design-highlighter-theme-changer-btn"><span>深色版本</span><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#tongyi-down-line"></use></svg></span></div></div><svg width="12" height="12" viewBox="0 0 11.199999809265137 11.199999809265137" class="cursor-pointer flex items-center tongyi-design-highlighter-copy-btn"><g><path d="M11.2,1.6C11.2,0.716344,10.4837,0,9.6,0L4.8,0C3.91634,0,3.2,0.716344,3.2,1.6L4.16,1.6Q4.16,1.3349,4.34745,1.14745Q4.5349,0.96,4.8,0.96L9.6,0.96Q9.8651,0.96,10.0525,1.14745Q10.24,1.3349,10.24,1.6L10.24,6.4Q10.24,6.6651,10.0525,6.85255Q9.8651,7.04,9.6,7.04L9.6,8C10.4837,8,11.2,7.28366,11.2,6.4L11.2,1.6ZM0,4L0,9.6C0,10.4837,0.716344,11.2,1.6,11.2L7.2,11.2C8.08366,11.2,8.8,10.4837,8.8,9.6L8.8,4C8.8,3.11634,8.08366,2.4,7.2,2.4L1.6,2.4C0.716344,2.4,0,3.11634,0,4ZM1.14745,10.0525Q0.96,9.8651,0.96,9.6L0.96,4Q0.96,3.7349,1.14745,3.54745Q1.3349,3.36,1.6,3.36L7.2,3.36Q7.4651,3.36,7.65255,3.54745Q7.84,3.7349,7.84,4L7.84,9.6Q7.84,9.8651,7.65255,10.0525Q7.4651,10.24,7.2,10.24L1.6,10.24Q1.3349,10.24,1.14745,10.0525Z"></path></g></svg></div></span><div><pre><code><span>long</span><span>* q;
</span><span>q++;  </span><span>// q += 8（long 是 8 字节）</span></code></pre></div></div></pre>

👉 **类型决定了步长**。

## 三、结构体指针：类型包含完整内存布局

<pre><div class="tongyi-design-highlighter global-dark-theme"><span class="tongyi-design-highlighter-header"><span class="tongyi-design-highlighter-lang">cpp</span><div class="tongyi-design-highlighter-right-actions"><div class="tongyi-design-highlighter-theme-changer"><div class="tongyi-design-highlighter-theme-changer-btn"><span>深色版本</span><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#tongyi-down-line"></use></svg></span></div></div><svg width="12" height="12" viewBox="0 0 11.199999809265137 11.199999809265137" class="cursor-pointer flex items-center tongyi-design-highlighter-copy-btn"><g><path d="M11.2,1.6C11.2,0.716344,10.4837,0,9.6,0L4.8,0C3.91634,0,3.2,0.716344,3.2,1.6L4.16,1.6Q4.16,1.3349,4.34745,1.14745Q4.5349,0.96,4.8,0.96L9.6,0.96Q9.8651,0.96,10.0525,1.14745Q10.24,1.3349,10.24,1.6L10.24,6.4Q10.24,6.6651,10.0525,6.85255Q9.8651,7.04,9.6,7.04L9.6,8C10.4837,8,11.2,7.28366,11.2,6.4L11.2,1.6ZM0,4L0,9.6C0,10.4837,0.716344,11.2,1.6,11.2L7.2,11.2C8.08366,11.2,8.8,10.4837,8.8,9.6L8.8,4C8.8,3.11634,8.08366,2.4,7.2,2.4L1.6,2.4C0.716344,2.4,0,3.11634,0,4ZM1.14745,10.0525Q0.96,9.8651,0.96,9.6L0.96,4Q0.96,3.7349,1.14745,3.54745Q1.3349,3.36,1.6,3.36L7.2,3.36Q7.4651,3.36,7.65255,3.54745Q7.84,3.7349,7.84,4L7.84,9.6Q7.84,9.8651,7.65255,10.0525Q7.4651,10.24,7.2,10.24L1.6,10.24Q1.3349,10.24,1.14745,10.0525Z"></path></g></svg></div></span><div><pre><code>struct Person {<span>
</span><span>    </span><span>char</span><span> name[</span>32<span>];   </span><span>// 32 字节</span><span>
</span><span>    </span><span>int</span><span> age;         </span><span>// 4 字节</span><span>
</span><span>    </span><span>double</span><span> salary;   </span><span>// 8 字节</span><span>
</span><span>}; </span><span>// 总共 44 字节（可能有对齐，实际 48）</span><span>
</span>
Person person;
Person* ptr = &person;</code></pre></div></div></pre>

* `ptr` 存的是 `&person` 这个地址（8字节）
* 但 `ptr` 的类型是 `Person*`
* 编译器在编译时就知道 `Person` 的大小、成员偏移

所以你可以写：

<pre><div class="tongyi-design-highlighter global-dark-theme"><span class="tongyi-design-highlighter-header"><span class="tongyi-design-highlighter-lang">cpp</span><div class="tongyi-design-highlighter-right-actions"><div class="tongyi-design-highlighter-theme-changer"><div class="tongyi-design-highlighter-theme-changer-btn"><span>深色版本</span><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#tongyi-down-line"></use></svg></span></div></div><svg width="12" height="12" viewBox="0 0 11.199999809265137 11.199999809265137" class="cursor-pointer flex items-center tongyi-design-highlighter-copy-btn"><g><path d="M11.2,1.6C11.2,0.716344,10.4837,0,9.6,0L4.8,0C3.91634,0,3.2,0.716344,3.2,1.6L4.16,1.6Q4.16,1.3349,4.34745,1.14745Q4.5349,0.96,4.8,0.96L9.6,0.96Q9.8651,0.96,10.0525,1.14745Q10.24,1.3349,10.24,1.6L10.24,6.4Q10.24,6.6651,10.0525,6.85255Q9.8651,7.04,9.6,7.04L9.6,8C10.4837,8,11.2,7.28366,11.2,6.4L11.2,1.6ZM0,4L0,9.6C0,10.4837,0.716344,11.2,1.6,11.2L7.2,11.2C8.08366,11.2,8.8,10.4837,8.8,9.6L8.8,4C8.8,3.11634,8.08366,2.4,7.2,2.4L1.6,2.4C0.716344,2.4,0,3.11634,0,4ZM1.14745,10.0525Q0.96,9.8651,0.96,9.6L0.96,4Q0.96,3.7349,1.14745,3.54745Q1.3349,3.36,1.6,3.36L7.2,3.36Q7.4651,3.36,7.65255,3.54745Q7.84,3.7349,7.84,4L7.84,9.6Q7.84,9.8651,7.65255,10.0525Q7.4651,10.24,7.2,10.24L1.6,10.24Q1.3349,10.24,1.14745,10.0525Z"></path></g></svg></div></span><div><pre><code><span>ptr->age = </span>25<span>;  </span><span>// 编译器知道：从 ptr 地址开始，偏移 32 字节，写 4 字节的 int</span></code></pre></div></div></pre>

👉 类型提供了**元数据（metadata）**：大小、对齐、成员布局。

---

## ✅ 四、`void*`：没有类型的指针

<pre><div class="tongyi-design-highlighter global-dark-theme"><span class="tongyi-design-highlighter-header"><span class="tongyi-design-highlighter-lang">cpp</span><div class="tongyi-design-highlighter-right-actions"><div class="tongyi-design-highlighter-theme-changer"><div class="tongyi-design-highlighter-theme-changer-btn"><span>深色版本</span><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#tongyi-down-line"></use></svg></span></div></div><svg width="12" height="12" viewBox="0 0 11.199999809265137 11.199999809265137" class="cursor-pointer flex items-center tongyi-design-highlighter-copy-btn"><g><path d="M11.2,1.6C11.2,0.716344,10.4837,0,9.6,0L4.8,0C3.91634,0,3.2,0.716344,3.2,1.6L4.16,1.6Q4.16,1.3349,4.34745,1.14745Q4.5349,0.96,4.8,0.96L9.6,0.96Q9.8651,0.96,10.0525,1.14745Q10.24,1.3349,10.24,1.6L10.24,6.4Q10.24,6.6651,10.0525,6.85255Q9.8651,7.04,9.6,7.04L9.6,8C10.4837,8,11.2,7.28366,11.2,6.4L11.2,1.6ZM0,4L0,9.6C0,10.4837,0.716344,11.2,1.6,11.2L7.2,11.2C8.08366,11.2,8.8,10.4837,8.8,9.6L8.8,4C8.8,3.11634,8.08366,2.4,7.2,2.4L1.6,2.4C0.716344,2.4,0,3.11634,0,4ZM1.14745,10.0525Q0.96,9.8651,0.96,9.6L0.96,4Q0.96,3.7349,1.14745,3.54745Q1.3349,3.36,1.6,3.36L7.2,3.36Q7.4651,3.36,7.65255,3.54745Q7.84,3.7349,7.84,4L7.84,9.6Q7.84,9.8651,7.65255,10.0525Q7.4651,10.24,7.2,10.24L1.6,10.24Q1.3349,10.24,1.14745,10.0525Z"></path></g></svg></div></span><div><pre><code><span>void</span><span>* ptr = &x;
</span><span></span><span>// *ptr;     // ❌ 错误！不知道读多少字节</span><span>
</span><span></span><span>// ptr + 1;  // ❌ 错误！不知道步长</span></code></pre></div></div></pre>

* `void*` 只存地址，没有类型信息。
* 不能解引用，不能做指针运算。
* 必须先转换为具体类型：

<pre><div class="tongyi-design-highlighter global-dark-theme"><span class="tongyi-design-highlighter-header"><span class="tongyi-design-highlighter-lang">cpp</span><div class="tongyi-design-highlighter-right-actions"><div class="tongyi-design-highlighter-theme-changer"><div class="tongyi-design-highlighter-theme-changer-btn"><span>深色版本</span><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#tongyi-down-line"></use></svg></span></div></div><svg width="12" height="12" viewBox="0 0 11.199999809265137 11.199999809265137" class="cursor-pointer flex items-center tongyi-design-highlighter-copy-btn"><g><path d="M11.2,1.6C11.2,0.716344,10.4837,0,9.6,0L4.8,0C3.91634,0,3.2,0.716344,3.2,1.6L4.16,1.6Q4.16,1.3349,4.34745,1.14745Q4.5349,0.96,4.8,0.96L9.6,0.96Q9.8651,0.96,10.0525,1.14745Q10.24,1.3349,10.24,1.6L10.24,6.4Q10.24,6.6651,10.0525,6.85255Q9.8651,7.04,9.6,7.04L9.6,8C10.4837,8,11.2,7.28366,11.2,6.4L11.2,1.6ZM0,4L0,9.6C0,10.4837,0.716344,11.2,1.6,11.2L7.2,11.2C8.08366,11.2,8.8,10.4837,8.8,9.6L8.8,4C8.8,3.11634,8.08366,2.4,7.2,2.4L1.6,2.4C0.716344,2.4,0,3.11634,0,4ZM1.14745,10.0525Q0.96,9.8651,0.96,9.6L0.96,4Q0.96,3.7349,1.14745,3.54745Q1.3349,3.36,1.6,3.36L7.2,3.36Q7.4651,3.36,7.65255,3.54745Q7.84,3.7349,7.84,4L7.84,9.6Q7.84,9.8651,7.65255,10.0525Q7.4651,10.24,7.2,10.24L1.6,10.24Q1.3349,10.24,1.14745,10.0525Z"></path></g></svg></div></span><div><pre><code><span>int</span><span>* p = (</span><span>int</span><span>*)ptr;  </span><span>// 告诉编译器：“它其实是个 int*”</span></code></pre></div></div></pre>

👉 这反向证明：**类型是关键**。

## 五、类型信息是编译时决定的


| 信息                            | 存储位置          | 何时使用   |
| ------------------------------- | ----------------- | ---------- |
| 指针的值（地址）                | 运行时内存/寄存器 | 程序执行时 |
| 指针的类型（`int*`, `Person*`） | 编译器符号表      | 编译时     |

* 编译器在编译时就知道每个类型的大小。
* 它根据类型生成正确的汇编代码。
* 运行时，CPU 只看到地址，但代码已经是“读4字节”或“跳8字节”了。

---

## ✅ 六、图解：指针 + 类型 如何工作

<pre><div class="tongyi-design-highlighter global-dark-theme"><span class="tongyi-design-highlighter-header"><span class="tongyi-design-highlighter-lang"></span><div class="tongyi-design-highlighter-right-actions"><div class="tongyi-design-highlighter-theme-changer"><div class="tongyi-design-highlighter-theme-changer-btn"><span>深色版本</span><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#tongyi-down-line"></use></svg></span></div></div><svg width="12" height="12" viewBox="0 0 11.199999809265137 11.199999809265137" class="cursor-pointer flex items-center tongyi-design-highlighter-copy-btn"><g><path d="M11.2,1.6C11.2,0.716344,10.4837,0,9.6,0L4.8,0C3.91634,0,3.2,0.716344,3.2,1.6L4.16,1.6Q4.16,1.3349,4.34745,1.14745Q4.5349,0.96,4.8,0.96L9.6,0.96Q9.8651,0.96,10.0525,1.14745Q10.24,1.3349,10.24,1.6L10.24,6.4Q10.24,6.6651,10.0525,6.85255Q9.8651,7.04,9.6,7.04L9.6,8C10.4837,8,11.2,7.28366,11.2,6.4L11.2,1.6ZM0,4L0,9.6C0,10.4837,0.716344,11.2,1.6,11.2L7.2,11.2C8.08366,11.2,8.8,10.4837,8.8,9.6L8.8,4C8.8,3.11634,8.08366,2.4,7.2,2.4L1.6,2.4C0.716344,2.4,0,3.11634,0,4ZM1.14745,10.0525Q0.96,9.8651,0.96,9.6L0.96,4Q0.96,3.7349,1.14745,3.54745Q1.3349,3.36,1.6,3.36L7.2,3.36Q7.4651,3.36,7.65255,3.54745Q7.84,3.7349,7.84,4L7.84,9.6Q7.84,9.8651,7.65255,10.0525Q7.4651,10.24,7.2,10.24L1.6,10.24Q1.3349,10.24,1.14745,10.0525Z"></path></g></svg></div></span><div><pre><code><span>内存：
</span>地址:     0x1000      0x1004      0x1008
        +--------+  +--------+  +--------+
        |   10   |  |   20   |  |   30   |
        +--------+  +--------+  +--------+
           int       int        int

指针：
int* p = 0x1000;  // p 的值是 0x1000，类型是 int*

p++ → p = 0x1000 + 4 = 0x1004</code></pre></div></div></pre>

* `p` 的值是地址
* `p` 的类型告诉编译器：“每次 +1，跳 4 字节”

---

## ✅ 七、总结：一句话说透

> **指针存储的只是地址（4或8字节），但它所指向对象的大小、布局、操作方式，都由它的“类型”在编译时决定。**

### 类比：快递单 + 商品说明书

* **指针的值（地址）** = 快递单上的收货地址
* **指针的类型** = 商品说明书（告诉快递员：这是冰箱，要搬4个人，放厨房）
* **解引用 `*p`** = 按说明书从地址取货
* **指针运算 `p++`** = 按说明书决定下一站走多远

没有说明书（类型），光有地址，你不知道怎么处理货物。

---

### ✅ 补充：`sizeof` 和类型

<pre><div class="tongyi-design-highlighter global-dark-theme"><span class="tongyi-design-highlighter-header"><span class="tongyi-design-highlighter-lang">cpp</span><div class="tongyi-design-highlighter-right-actions"><div class="tongyi-design-highlighter-theme-changer"><div class="tongyi-design-highlighter-theme-changer-btn"><span>深色版本</span><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#tongyi-down-line"></use></svg></span></div></div><svg width="12" height="12" viewBox="0 0 11.199999809265137 11.199999809265137" class="cursor-pointer flex items-center tongyi-design-highlighter-copy-btn"><g><path d="M11.2,1.6C11.2,0.716344,10.4837,0,9.6,0L4.8,0C3.91634,0,3.2,0.716344,3.2,1.6L4.16,1.6Q4.16,1.3349,4.34745,1.14745Q4.5349,0.96,4.8,0.96L9.6,0.96Q9.8651,0.96,10.0525,1.14745Q10.24,1.3349,10.24,1.6L10.24,6.4Q10.24,6.6651,10.0525,6.85255Q9.8651,7.04,9.6,7.04L9.6,8C10.4837,8,11.2,7.28366,11.2,6.4L11.2,1.6ZM0,4L0,9.6C0,10.4837,0.716344,11.2,1.6,11.2L7.2,11.2C8.08366,11.2,8.8,10.4837,8.8,9.6L8.8,4C8.8,3.11634,8.08366,2.4,7.2,2.4L1.6,2.4C0.716344,2.4,0,3.11634,0,4ZM1.14745,10.0525Q0.96,9.8651,0.96,9.6L0.96,4Q0.96,3.7349,1.14745,3.54745Q1.3349,3.36,1.6,3.36L7.2,3.36Q7.4651,3.36,7.65255,3.54745Q7.84,3.7349,7.84,4L7.84,9.6Q7.84,9.8651,7.65255,10.0525Q7.4651,10.24,7.2,10.24L1.6,10.24Q1.3349,10.24,1.14745,10.0525Z"></path></g></svg></div></span><div><pre><code><span>int</span><span>* p;
</span><span>cout << </span><span>sizeof</span><span>(p);     </span><span>// 8（指针本身的大小）</span><span>
</span><span>cout << </span><span>sizeof</span><span>(*p);    </span><span>// 4（p 指向的 int 的大小）</span></code></pre></div></div></pre>

* `sizeof(*p)` 是在编译时计算的，基于 `p` 的类型。

---

你现在理解了 C++ 类型系统如何与指针协同工作：**类型是编译器的“地图”，指针是运行时的“坐标”**。

# 指针和python、java中的引用

## ✅ 一、直接答案：

> ✅ **Python 和 Java 并不是“没有指针”，而是“没有暴露原始指针”**。
> ❌ **它们不是简单地“封装了指针”，而是“指针被语言底层隐藏，只保留引用语义”**。

你可以理解为：

> **“指针被抽象成了‘引用’（reference），并且不允许直接操作内存地址。”**

---

## ✅ 二、C++ vs Python/Java：内存模型对比


| 特性                     | C++                              | Python / Java                      |
| ------------------------ | -------------------------------- | ---------------------------------- |
| 是否允许直接操作内存地址 | ✅ 是（`&`, `*`, `ptr+1`）       | ❌ 否                              |
| 是否有原始指针类型       | ✅`int*`, `void*`                | ❌ 没有                            |
| 变量本质                 | 可以是栈上对象，也可以是指针     | 所有变量都是“引用”（指向堆对象） |
| 内存管理                 | 手动或智能指针                   | 自动垃圾回收（GC）                 |
| 安全性                   | 高（但易出错：野指针、内存泄漏） | 高（避免内存错误）                 |

---

## ✅ 三、Python 和 Java 中的“指针去哪儿了？”

### 1. Python：一切是对象，变量是引用

<pre><div class="tongyi-design-highlighter global-dark-theme"><span class="tongyi-design-highlighter-header"><span class="tongyi-design-highlighter-lang">python</span><div class="tongyi-design-highlighter-right-actions"><div class="tongyi-design-highlighter-theme-changer"><div class="tongyi-design-highlighter-theme-changer-btn"><span>深色版本</span><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#tongyi-down-line"></use></svg></span></div></div><svg width="12" height="12" viewBox="0 0 11.199999809265137 11.199999809265137" class="cursor-pointer flex items-center tongyi-design-highlighter-copy-btn"><g><path d="M11.2,1.6C11.2,0.716344,10.4837,0,9.6,0L4.8,0C3.91634,0,3.2,0.716344,3.2,1.6L4.16,1.6Q4.16,1.3349,4.34745,1.14745Q4.5349,0.96,4.8,0.96L9.6,0.96Q9.8651,0.96,10.0525,1.14745Q10.24,1.3349,10.24,1.6L10.24,6.4Q10.24,6.6651,10.0525,6.85255Q9.8651,7.04,9.6,7.04L9.6,8C10.4837,8,11.2,7.28366,11.2,6.4L11.2,1.6ZM0,4L0,9.6C0,10.4837,0.716344,11.2,1.6,11.2L7.2,11.2C8.08366,11.2,8.8,10.4837,8.8,9.6L8.8,4C8.8,3.11634,8.08366,2.4,7.2,2.4L1.6,2.4C0.716344,2.4,0,3.11634,0,4ZM1.14745,10.0525Q0.96,9.8651,0.96,9.6L0.96,4Q0.96,3.7349,1.14745,3.54745Q1.3349,3.36,1.6,3.36L7.2,3.36Q7.4651,3.36,7.65255,3.54745Q7.84,3.7349,7.84,4L7.84,9.6Q7.84,9.8651,7.65255,10.0525Q7.4651,10.24,7.2,10.24L1.6,10.24Q1.3349,10.24,1.14745,10.0525Z"></path></g></svg></div></span><div><pre><code><span>a = [</span>1<span>, </span>2<span>, </span>3<span>]
</span>b = a</code></pre></div></div></pre>

* `a` 和 `b` 都是“引用”，指向同一个列表对象。
* 你不能写 `a + 1` 或 `*a`，不能直接操作地址。
* 但底层实现上，`a` 本质上就是一个指针（存储对象地址）。

👉 **Python 的“变量”就是被安全封装的指针**，但你不能：

* 取地址（`&a`）
* 解引用（`*a`）
* 指针运算（`a++`）

### 2. Java：引用（reference）替代指针

<pre><div class="tongyi-design-highlighter global-dark-theme"><span class="tongyi-design-highlighter-header"><span class="tongyi-design-highlighter-lang">java</span><div class="tongyi-design-highlighter-right-actions"><div class="tongyi-design-highlighter-theme-changer"><div class="tongyi-design-highlighter-theme-changer-btn"><span>深色版本</span><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#tongyi-down-line"></use></svg></span></div></div><svg width="12" height="12" viewBox="0 0 11.199999809265137 11.199999809265137" class="cursor-pointer flex items-center tongyi-design-highlighter-copy-btn"><g><path d="M11.2,1.6C11.2,0.716344,10.4837,0,9.6,0L4.8,0C3.91634,0,3.2,0.716344,3.2,1.6L4.16,1.6Q4.16,1.3349,4.34745,1.14745Q4.5349,0.96,4.8,0.96L9.6,0.96Q9.8651,0.96,10.0525,1.14745Q10.24,1.3349,10.24,1.6L10.24,6.4Q10.24,6.6651,10.0525,6.85255Q9.8651,7.04,9.6,7.04L9.6,8C10.4837,8,11.2,7.28366,11.2,6.4L11.2,1.6ZM0,4L0,9.6C0,10.4837,0.716344,11.2,1.6,11.2L7.2,11.2C8.08366,11.2,8.8,10.4837,8.8,9.6L8.8,4C8.8,3.11634,8.08366,2.4,7.2,2.4L1.6,2.4C0.716344,2.4,0,3.11634,0,4ZM1.14745,10.0525Q0.96,9.8651,0.96,9.6L0.96,4Q0.96,3.7349,1.14745,3.54745Q1.3349,3.36,1.6,3.36L7.2,3.36Q7.4651,3.36,7.65255,3.54745Q7.84,3.7349,7.84,4L7.84,9.6Q7.84,9.8651,7.65255,10.0525Q7.4651,10.24,7.2,10.24L1.6,10.24Q1.3349,10.24,1.14745,10.0525Z"></path></g></svg></div></span><div><pre><code><span>List<Integer> list = </span><span>new</span><span> ArrayList<>();
</span><span>list.add(</span>1<span>);</span></code></pre></div></div></pre>

* `list` 是一个“引用”，不是原始指针。
* 你不能进行指针运算，不能直接访问内存。
* 所有对象都在堆上，变量只是引用。

Java 明确规定：

> “Java does not have pointers.”
> 但它有 `reference`，行为类似指针，但更安全。

## 四、为什么高级语言要“隐藏指针”？

### 1. 安全性（最主要原因）

C++ 指针的危险操作：

<pre><div class="tongyi-design-highlighter global-dark-theme"><span class="tongyi-design-highlighter-header"><span class="tongyi-design-highlighter-lang">cpp</span><div class="tongyi-design-highlighter-right-actions"><div class="tongyi-design-highlighter-theme-changer"><div class="tongyi-design-highlighter-theme-changer-btn"><span>深色版本</span><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#tongyi-down-line"></use></svg></span></div></div><svg width="12" height="12" viewBox="0 0 11.199999809265137 11.199999809265137" class="cursor-pointer flex items-center tongyi-design-highlighter-copy-btn"><g><path d="M11.2,1.6C11.2,0.716344,10.4837,0,9.6,0L4.8,0C3.91634,0,3.2,0.716344,3.2,1.6L4.16,1.6Q4.16,1.3349,4.34745,1.14745Q4.5349,0.96,4.8,0.96L9.6,0.96Q9.8651,0.96,10.0525,1.14745Q10.24,1.3349,10.24,1.6L10.24,6.4Q10.24,6.6651,10.0525,6.85255Q9.8651,7.04,9.6,7.04L9.6,8C10.4837,8,11.2,7.28366,11.2,6.4L11.2,1.6ZM0,4L0,9.6C0,10.4837,0.716344,11.2,1.6,11.2L7.2,11.2C8.08366,11.2,8.8,10.4837,8.8,9.6L8.8,4C8.8,3.11634,8.08366,2.4,7.2,2.4L1.6,2.4C0.716344,2.4,0,3.11634,0,4ZM1.14745,10.0525Q0.96,9.8651,0.96,9.6L0.96,4Q0.96,3.7349,1.14745,3.54745Q1.3349,3.36,1.6,3.36L7.2,3.36Q7.4651,3.36,7.65255,3.54745Q7.84,3.7349,7.84,4L7.84,9.6Q7.84,9.8651,7.65255,10.0525Q7.4651,10.24,7.2,10.24L1.6,10.24Q1.3349,10.24,1.14745,10.0525Z"></path></g></svg></div></span><div><pre><code><span>int</span><span>* p = </span><span>nullptr</span><span>;
</span><span>*p = </span>10<span>;        </span><span>// 段错误（Segmentation fault）</span><span>
</span>
<span></span><span>int</span><span> arr[</span>3<span>];
</span>p = arr;
<span>p[</span>-1000<span>] = </span>1<span>;   </span><span>// 内存越界，可能破坏程序</span><span>
</span>
<span>p = (</span><span>int</span><span>*)</span>0x1234<span>;
</span><span>*p = </span>1<span>;         </span><span>// 直接写内存，系统崩溃</span></code></pre></div></div></pre>

Python/Java 避免了这些问题：

<pre><div class="tongyi-design-highlighter global-dark-theme"><span class="tongyi-design-highlighter-header"><span class="tongyi-design-highlighter-lang">python</span><div class="tongyi-design-highlighter-right-actions"><div class="tongyi-design-highlighter-theme-changer"><div class="tongyi-design-highlighter-theme-changer-btn"><span>深色版本</span><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#tongyi-down-line"></use></svg></span></div></div><svg width="12" height="12" viewBox="0 0 11.199999809265137 11.199999809265137" class="cursor-pointer flex items-center tongyi-design-highlighter-copy-btn"><g><path d="M11.2,1.6C11.2,0.716344,10.4837,0,9.6,0L4.8,0C3.91634,0,3.2,0.716344,3.2,1.6L4.16,1.6Q4.16,1.3349,4.34745,1.14745Q4.5349,0.96,4.8,0.96L9.6,0.96Q9.8651,0.96,10.0525,1.14745Q10.24,1.3349,10.24,1.6L10.24,6.4Q10.24,6.6651,10.0525,6.85255Q9.8651,7.04,9.6,7.04L9.6,8C10.4837,8,11.2,7.28366,11.2,6.4L11.2,1.6ZM0,4L0,9.6C0,10.4837,0.716344,11.2,1.6,11.2L7.2,11.2C8.08366,11.2,8.8,10.4837,8.8,9.6L8.8,4C8.8,3.11634,8.08366,2.4,7.2,2.4L1.6,2.4C0.716344,2.4,0,3.11634,0,4ZM1.14745,10.0525Q0.96,9.8651,0.96,9.6L0.96,4Q0.96,3.7349,1.14745,3.54745Q1.3349,3.36,1.6,3.36L7.2,3.36Q7.4651,3.36,7.65255,3.54745Q7.84,3.7349,7.84,4L7.84,9.6Q7.84,9.8651,7.65255,10.0525Q7.4651,10.24,7.2,10.24L1.6,10.24Q1.3349,10.24,1.14745,10.0525Z"></path></g></svg></div></span><div><pre><code><span>lst = [</span>1<span>, </span>2<span>, </span>3<span>]
</span><span></span><span># lst[-1000] = 1  # IndexError，抛异常，不会崩溃</span></code></pre></div></div></pre>

---

### 2. 简化编程模型

* 新手不需要理解“栈 vs 堆”、“指针 vs 对象”。
* 所有变量都是“名字”，所有对象都在堆上。
* 开发者专注于逻辑，而不是内存管理。

---

### 3. 支持垃圾回收（GC）

* GC 需要控制对象的生命周期。
* 如果允许原始指针，GC 无法追踪对象是否还在被引用。
* 而“引用”是受控的，GC 可以管理。

---

### 4. 跨平台一致性

* 原始指针依赖硬件（32位/64位地址）。
* 高级语言希望“一次编写，到处运行”。
* 隐藏指针，让语言运行在虚拟机（JVM）或解释器（CPython）之上。

---

## ✅ 五、那是不是“封装了指针”？

### 严格来说：

> ❌ **不是“封装了一个指针类”**，而是：

> ✅ **“语言设计上用‘引用’替代了‘指针’，并禁止直接内存操作”**

* Python 的 `list` 变量本质上是一个指针（C 结构体 `PyListObject*`）
* Java 的 `String` 变量本质上是一个指针（JVM 内部是 `oop` 指针）
* 但语言层面不暴露，也不允许你做指针运算。

👉 这不是“封装”，而是 **“抽象 + 限制”**。



# 引用


## 1. 引用的本质 (What is a reference?)

* **定义**：引用（Reference）是一个**已存在变量的别名**。它不是一个新变量，而是为某个已存在的变量提供了另一个名字。
* **与指针的关系**：图片1明确指出，**引用本质上是指针的一种语法糖**。它基于指针实现，目的是让代码更易于读写和理解。没有引用能做而指针不能做的事。
* **关键区别**：与指针不同，引用**必须在其声明时就被初始化**，并且**一旦绑定到一个变量，就无法再改变为另一个变量的别名**（即不可重新绑定）。

## 2. 引用的声明与使用

* **语法**：通过 `类型& 引用名 = 原变量名;`来声明。这里的 `&`是类型标识的一部分，而不是取地址操作符。

  <pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">int a = 5;
  int& ref = a; // ref 现在是变量a的别名</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>
* **效果**：此后，对引用 `ref`的任何操作都等同于直接对原变量 `a`进行操作。`ref`就是 `a`，两者在内存中代表同一个位置。

## 3. 引用的核心特性

1. **必须初始化**：引用在声明时必须指定其引用的变量，不能先声明后赋值。

   <pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">// int& bad_ref; // 错误！引用必须初始化
   int b = 8;
   int& good_ref = b; // 正确</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>
2. **不可重新绑定**：一个引用在其生命周期内只能作为一个变量的别名，无法让其后续再引用另一个变量。

   <pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">int a = 5;
   int b = 8;
   int& ref = a;
   ref = b; // 这并非让ref引用b！这只是将b的值(8)赋值给ref(也就是a)，现在a的值变为8。</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>
3. **无独立内存**：引用本身不占用额外的存储空间（从标准层面看，它是其引用对象的别名）。图片1提到“引用本身并不是一个新的变量，并不真正占用内存”。


## 4. 引用的主要用途：函数参数传递

* **按值传递 (Pass-by-Value)**：函数接收到的是实参的一个副本。在函数内部修改形参**不会影响**外部的实参。

  <pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">void Increment(int value) {
      value++; // 只修改副本
  }
  // a 的值不会改变</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>
* **按引用传递 (Pass-by-Reference)**：函数形参是一个引用，它直接绑定到外部的实参上。对形参的修改**直接作用**于实参。

  <pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">void Increment(int& value) { // 使用引用
      value++; // 直接修改实参
  }
  // a 的值会增加1</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>
* **优势**：相比于使用指针（`int* value`）需要在函数内部解引用（`(*value)++`），使用引用**语法更简洁、可读性更强**，效果却完全相同。图片3的标题“用reference的方式”和代码对比清晰地展示了这一优势。


## 5. 如何“改变”引用？

由于引用本身不可重新绑定，如果你需要实现“指向不同对象”的功能，你应该使用**指针**。

图片3下方指出：“如果想修改引用，则可以通过指针的方式(指针可以改变指向的对象，而引用不行)”。

这意味着，你可以创建一个指针，让其指向某个引用（即取引用的地址），然后通过修改该指针的值来间接改变它所指向的内容（也就是原引用的目标变量）。

<pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">int a = 5;
int b = 10;
int& ref = a; // ref是a的别名

int* ptr = &ref; // ptr指向ref（也就是指向a）
*ptr = 6;       // 现在 a = 6

ptr = &b;       // ptr现在指向了b（注意：这只是改变了ptr，ref仍然是a的别名）
*ptr = 11;      // 现在 b = 11, a仍然是6</code></div></div></pre></div></pre>



## 核心思想总结

引用是一个强大的工具，其核心价值在于：

1. **作为别名**：提供一种更安全、更直观的方式来操作已存在的变量。
2. **简化语法**：作为指针的“语法糖”，在函数参数传递等场景下，它避免了繁琐的取地址(`&`)和解引用(`*`)操作，使代码**更清晰、更简洁、可读性更强**。
3. **增强安全**：由于必须初始化和不可重新绑定的特性，它在某些场景下比指针更安全，避免了空指针或“野指针”的问题。

**何时使用引用？**

当你需要为一个变量起一个更易懂的别名时，或者尤其是在函数参数传递中，希望直接修改实参而不进行拷贝时，引用是首选方案。当你需要“指向”不同对象或需要表示“可能不存在”的对象时，则应使用指针。
