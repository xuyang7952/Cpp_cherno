# 复制与拷贝构造函数

## 一、核心概念总览


| 概念                       | 说明                                               |
| -------------------------- | -------------------------------------------------- |
| **拷贝（Copy）**           | 将一个对象的数据复制到另一个对象中。               |
| **拷贝构造函数**           | 当用一个已存在的对象初始化另一个新对象时自动调用。 |
| **浅拷贝（Shallow Copy）** | 只复制指针，两个对象共享同一块内存。危险！         |
| **深拷贝（Deep Copy）**    | 复制数据本身，每个对象拥有独立内存。安全！         |
| **引用传递**               | 避免不必要的复制，提高性能。                       |

## 二、详细解释 + 图解说明

### 1. 拷贝 vs 指针拷贝

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>int</span><span> a = </span>2<span>;
</span><span></span><span>int</span><span> b = a;  </span><span>// ✅ 拷贝：a 和 b 是两个独立变量</span></code></pre></div></div></pre>

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>Vector2* a = </span><span>new</span><span> Vector2();
</span><span>Vector2* b = a;  </span><span>// ❌ 指针拷贝：b 和 a 指向同一内存</span><span>
</span><span>b->x = </span>5<span>;        </span><span>// 修改 b，a 也会变！</span></code></pre></div></div></pre>

> 💡 **结论**：`T obj1 = obj2;` 是拷贝，`T* ptr1 = ptr2;` 是指针赋值，不是拷贝！

---

### 2. 拷贝构造函数（Copy Constructor）

当用一个对象初始化另一个对象时，会调用拷贝构造函数：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>String</span><span> str1 = </span><span>"Cherno"</span><span>;
</span><span></span><span>String</span><span> str2 = str1;  </span><span>// ✅ 调用拷贝构造函数</span></code></pre></div></div></pre>

如果类中有动态内存（如 `char*`），C++ 默认提供的是 **浅拷贝**，这会导致问题！

---

### 3. 浅拷贝的问题（图片中的崩溃原因）

#### 🔥 问题场景：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code>class String {<span>
</span><span></span><span>private</span><span>:
</span><span>    </span><span>char</span><span>* m_Buffer;
</span><span>    </span><span>unsigned</span><span> </span><span>int</span><span> m_Size;
</span><span></span><span>public</span><span>:
</span><span>    String(</span><span>const</span><span> </span><span>char</span><span>* </span><span>string</span><span>) {
</span><span>        m_Size = </span><span>strlen</span><span>(</span><span>string</span><span>);
</span><span>        m_Buffer = </span><span>new</span><span> </span><span>char</span><span>[m_Size];  </span><span>// ⚠️ 忘记 +1，且没加 '\0'</span><span>
</span><span>        </span><span>memcpy</span><span>(m_Buffer, </span><span>string</span><span>, m_Size);
</span>    }
    ~String() {
<span>        </span><span>delete</span><span>[] m_Buffer;  </span><span>// 析构函数</span><span>
</span>    }
};</code></pre></div></div></pre>

#### 👉 创建两个对象：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>String</span><span> </span><span>string</span><span> = </span><span>"Cherno"</span><span>;
</span><span></span><span>String</span><span> second = </span><span>string</span><span>;  </span><span>// ✅ 拷贝构造函数被调用</span></code></pre></div></div></pre>

默认拷贝构造函数是**浅拷贝**，即：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>String</span><span>(</span><span>const</span><span> </span><span>String</span><span>& other) : m_Buffer(other.m_Buffer), </span>m_Size(other.m_Size)<span> {}</span></code></pre></div></div></pre>

结果：

* `string.m_Buffer` 和 `second.m_Buffer` 指向**同一块内存**
* 两个对象都持有同一个 `char*`
* 程序结束时，两个析构函数都会调用 `delete[] m_Buffer` → **双重释放！崩溃！**

> 🔥 这就是图片中“wntdll.pdb not loaded”崩溃的原因！

---

### 4. 解决方案：深拷贝（Deep Copy）

我们要让每个对象都有自己的内存！

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>String</span><span>(</span><span>const</span><span> </span><span>String</span><span>& other)
</span><span>    : </span>m_Size(other.m_Size)<span>
</span>{
<span>    m_Buffer = </span><span>new</span><span> char[m_Size + </span>1<span>];  </span><span>// 分配新内存</span><span>
</span><span>    memcpy(m_Buffer, other.m_Buffer, m_Size + </span>1<span>);  </span><span>// 复制内容</span><span>
</span>}</code></pre></div></div></pre>

✅ 此时 `string` 和 `second` 各自拥有独立的内存，修改其中一个不会影响另一个。

---

### 5. 引用传递 vs 值传递（避免多余拷贝）

#### ❌ 值传递（引发多次拷贝）：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code>void PrintString(String string) <span>{  </span><span>// 值传递 → 触发拷贝构造</span><span>
</span><span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>string</span><span> << </span><span>std</span><span>::</span><span>endl</span><span>;
</span>}</code></pre></div></div></pre>

* 函数参数传入时：一次拷贝
* 函数内部使用时：可能再拷贝一次
* 性能差，尤其对大对象

#### ✅ 引用传递（推荐）：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code>void PrintString(const String& string) <span>{  </span><span>// const 引用 → 不拷贝</span><span>
</span><span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>string</span><span> << </span><span>std</span><span>::</span><span>endl</span><span>;
</span>}</code></pre></div></div></pre>

* 无拷贝，直接访问原对象
* 更高效，更安全

## 三、完整可运行代码（含所有知识点）

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code data-spm-anchor-id="5176.28103460.0.i30.5e842e317ELiV5"><span>#</span>include<span> </span><iostream><span>
</span><span></span><span>#</span>include<span> </span><cstring><span>
</span>
<span></span>class String {<span>
</span><span></span><span>private</span><span>:
</span><span>    </span><span>char</span><span>* m_Buffer;
</span><span>    </span><span>unsigned</span><span> </span><span>int</span><span> m_Size;
</span>
<span></span><span>public</span><span>:
</span><span>    </span><span>// 构造函数</span><span>
</span><span>    String(</span><span>const</span><span> </span><span>char</span><span>* </span><span>string</span><span>) {
</span><span>        m_Size = </span><span>strlen</span><span>(</span><span>string</span><span>);
</span><span>        m_Buffer = </span><span>new</span><span> </span><span>char</span><span>[m_Size + </span>1<span>];  </span><span>// +1 为 '\0'</span><span>
</span><span>        </span><span>memcpy</span><span>(m_Buffer, </span><span>string</span><span>, m_Size + </span>1<span>);
</span>    }

<span>    </span><span>// 拷贝构造函数（深拷贝）</span><span>
</span><span>    String(</span><span>const</span><span> String& other)
</span>        : m_Size(other.m_Size)
    {
<span>        m_Buffer = </span><span>new</span><span> </span><span>char</span><span>[m_Size + </span>1<span>];
</span><span>        </span><span>memcpy</span><span>(m_Buffer, other.m_Buffer, m_Size + </span>1<span>);
</span>    }

<span>    </span><span>// 析构函数</span><span>
</span>    ~String() {
<span>        </span><span>delete</span><span>[] m_Buffer;
</span>    }

<span>    </span><span>// 重载输出运算符</span><span>
</span><span>    </span><span>friend</span><span> </span><span>std</span><span>::ostream& </span><span>operator</span><span><<(</span><span>std</span><span>::ostream& stream, </span><span>const</span><span> String& </span><span>string</span><span>) {
</span><span>        stream << </span><span>string</span><span>.m_Buffer;
</span><span>        </span><span>return</span><span> stream;
</span>    }

<span>    </span><span>// 重载 [] 操作符</span><span>
</span><span>    </span><span>char</span><span>& </span><span>operator</span><span>[](</span><span>unsigned</span><span> </span><span>int</span><span> index) {
</span><span>        </span><span>return</span><span> m_Buffer[index];
</span>    }
};

<span></span><span>// 打印函数：使用 const 引用避免拷贝</span><span>
</span><span></span>void PrintString(const String& string) <span>{
</span><span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>string</span><span> << </span><span>std</span><span>::</span><span>endl</span><span>;
</span>}

<span></span>int main() <span>{
</span><span>    String </span><span>string</span><span> = </span><span>"Cherno"</span><span>;
</span><span>    String second = </span><span>string</span><span>;  </span><span>// 调用拷贝构造函数（深拷贝）</span><span>
</span>
<span>    second[</span>2<span>] = </span><span>'a'</span><span>;  </span><span>// 修改 second，不影响 string</span><span>
</span>
<span>    PrintString(</span><span>string</span><span>);  </span><span>// 输出: Cherno</span><span>
</span><span>    PrintString(second); </span><span>// 输出: Charo</span><span>
</span>
<span>    </span><span>std</span><span>::</span><span>cin</span><span>.get();  </span><span>// 等待输入</span><span>
</span><span>    </span><span>return</span><span> </span>0<span>;
</span>}</code></pre></div></div></pre>

---

## 📊 四、运行结果

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">text</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>Cherno
</span>Charo</code></pre></div></div></pre>

> ✅ 成功！没有崩溃，没有内存泄漏，修改 `second` 不影响 `string`。

## 五、总结图解（文字版）

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">text</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>浅拷贝（错误）：
</span><span>   </span><span>string</span><span>.m_Buffer → [内存块] ← second.m_Buffer
</span>                    ↑
<span>                   共享内存 → 两个析构函数都 </span><span>delete</span><span> → 双重释放 → 崩溃！
</span>
深拷贝（正确）：
<span>   </span><span>string</span><span>.m_Buffer → [内存块A]
</span>   second.m_Buffer → [内存块B]
                    ↑
<span>                   独立内存 → 各自 </span><span>delete</span><span> → 安全！
</span>
引用传递：
<span>   PrintString(</span><span>const</span><span> String& </span><span>string</span><span>) → 直接访问原始对象，不拷贝</span></code></pre></div></div></pre>

---

## ✅ 六、最佳实践建议


| 场景                    | 推荐方式                            |
| ----------------------- | ----------------------------------- |
| 类包含动态内存（`new`） | ✅ 必须实现深拷贝构造函数和析构函数 |
| 传递大对象给函数        | ✅ 使用`const T&` 引用传递          |
| 不允许拷贝              | ✅ 将拷贝构造函数声明为`= delete`   |
| 想避免复制              | ✅ 使用`std::move` 或智能指针       |

# python中的拷贝行为

## ✅ 一、Python 有“拷贝构造函数”吗？

### ❌ 没有 C++ 那种“拷贝构造函数”的概念。

但 Python 有**类似的机制**，只是更高级、更自动化。

### ✅ Python 中的“拷贝”方式：

1. **直接赋值（=）** → 只是**引用**，不是拷贝
2. **浅拷贝（shallow copy）**
3. **深拷贝（deep copy）**

Python 提供了标准库 `copy` 来支持后两者。

---

## ✅ 二、Python 的三大“复制”方式对比


| 方式              | 是否创建新对象  | 内存行为                   | 示例                   |
| ----------------- | --------------- | -------------------------- | ---------------------- |
| `=` 赋值          | ❌ 否           | 多个变量指向同一对象       | `b = a`                |
| `copy.copy()`     | ✅ 是（浅拷贝） | 第一层复制，嵌套对象仍共享 | `b = copy.copy(a)`     |
| `copy.deepcopy()` | ✅ 是（深拷贝） | 完全独立，递归复制所有层   | `b = copy.deepcopy(a)` |

我们用代码和图解来说明。

---

## ✅ 三、1. 直接赋值：只是“引用”

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">python</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>import</span><span> copy
</span>
<span>a = [</span>1<span>, </span>2<span>, [</span>3<span>, </span>4<span>]]
</span><span>b = a  </span><span># 只是让 b 指向 a 的对象</span><span>
</span>
<span>b[</span>0<span>] = </span>999<span>
</span><span>b[</span>2<span>][</span>0<span>] = </span>888<span>
</span>
<span></span><span>print</span><span>(</span><span>"a:"</span><span>, a)  </span><span># a: [999, 2, [888, 4]]</span><span>
</span><span></span><span>print</span><span>(</span><span>"b:"</span><span>, b)  </span><span># b: [999, 2, [888, 4]]</span></code></pre></div></div></pre>

👉 `a` 和 `b` 是**同一个列表对象**，修改 `b` 就是修改 `a`。

> 🔥 这就像 C++ 中的指针赋值：`T* b = a;`

---

## ✅ 三、2. 浅拷贝（Shallow Copy）

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">python</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>a = [</span>1<span>, </span>2<span>, [</span>3<span>, </span>4<span>]]
</span><span>b = copy.copy(a)  </span><span># 浅拷贝</span><span>
</span>
<span></span><span># 修改第一层</span><span>
</span><span>b[</span>0<span>] = </span>999<span>
</span>
<span></span><span># 修改嵌套列表</span><span>
</span><span>b[</span>2<span>][</span>0<span>] = </span>888<span>
</span>
<span></span><span>print</span><span>(</span><span>"a:"</span><span>, a)  </span><span># a: [1, 2, [888, 4]]</span><span>
</span><span></span><span>print</span><span>(</span><span>"b:"</span><span>, b)  </span><span># b: [999, 2, [888, 4]]</span></code></pre></div></div></pre>

### 🤔 发生了什么？

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">text</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>a → [1, 2, ──→ [3, 4] ←─── b（浅拷贝）
</span>b → [999, 2, ──┘</code></pre></div></div></pre>

* 列表对象本身被复制了（`b` 是新列表）
* 但嵌套的 `[3,4]` **没有被复制**，`a[2]` 和 `b[2]` 仍指向同一个列表

👉 所以修改 `b[2][0]` 会影响 `a[2][0]`

> ✅ 浅拷贝：只复制最外层容器，内部对象仍共享。

---

## ✅ 三、3. 深拷贝（Deep Copy）

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">python</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>a = [</span>1<span>, </span>2<span>, [</span>3<span>, </span>4<span>]]
</span><span>b = copy.deepcopy(a)  </span><span># 深拷贝</span><span>
</span>
<span>b[</span>0<span>] = </span>999<span>
</span><span>b[</span>2<span>][</span>0<span>] = </span>888<span>
</span>
<span></span><span>print</span><span>(</span><span>"a:"</span><span>, a)  </span><span># a: [1, 2, [3, 4]]</span><span>
</span><span></span><span>print</span><span>(</span><span>"b:"</span><span>, b)  </span><span># b: [999, 2, [888, 4]]</span></code></pre></div></div></pre>

### 🤔 发生了什么？

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">text</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>a → [1, 2, ──→ [3, 4]
</span>b → [999, 2, ──→ [888, 4]</code></pre></div></div></pre>

* 所有层级都被递归复制
* `a` 和 `b` 完全独立

> ✅ 深拷贝：创建一个**完全独立的副本**，修改互不影响。

## ✅ 四、自定义类中的拷贝行为

Python 允许你在类中自定义拷贝行为：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">python</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>import</span><span> copy
</span>
<span></span>class Person:<span>
</span><span>    </span>def __init__(self, name, age, hobbies):<span>
</span>        self.name = name
        self.age = age
<span>        self.hobbies = hobbies  </span><span># list</span><span>
</span>
<span>    </span>def __repr__(self):<span>
</span><span>        </span><span>return</span><span> </span><span>f"Person(</span>{self.name}<span>, </span>{self.age}<span>, </span>{self.hobbies}<span>)"</span><span>
</span>
<span></span><span># 创建对象</span><span>
</span><span>p1 = Person(</span><span>"Alice"</span><span>, </span>25<span>, [</span><span>"reading"</span><span>, </span><span>"music"</span><span>])
</span>
<span></span><span># 浅拷贝</span><span>
</span>p2 = copy.copy(p1)
<span>p2.hobbies.append(</span><span>"painting"</span><span>)
</span>
<span></span><span>print</span><span>(</span><span>"p1:"</span><span>, p1)  </span><span># hobbies 包含 painting！</span><span>
</span><span></span><span>print</span><span>(</span><span>"p2:"</span><span>, p2)
</span>
<span></span><span># 深拷贝</span><span>
</span>p3 = copy.deepcopy(p1)
<span>p3.hobbies.append(</span><span>"dancing"</span><span>)
</span>
<span></span><span>print</span><span>(</span><span>"p1:"</span><span>, p1)  </span><span># hobbies 不变</span><span>
</span><span></span><span>print</span><span>(</span><span>"p3:"</span><span>, p3)</span></code></pre></div></div></pre>

输出：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">text</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>p1: Person(Alice, </span>25<span>, [</span><span>'reading'</span><span>, </span><span>'music'</span><span>, </span><span>'painting'</span><span>])
</span><span>p2: Person(Alice, </span>25<span>, [</span><span>'reading'</span><span>, </span><span>'music'</span><span>, </span><span>'painting'</span><span>])
</span><span>p1: Person(Alice, </span>25<span>, [</span><span>'reading'</span><span>, </span><span>'music'</span><span>, </span><span>'painting'</span><span>])
</span><span>p3: Person(Alice, </span>25<span>, [</span><span>'reading'</span><span>, </span><span>'music'</span><span>, </span><span>'painting'</span><span>, </span><span>'dancing'</span><span>])</span></code></pre></div></div></pre>

---

## ✅ 五、C++ vs Python 拷贝对比


| 特性         | C++                    | Python                                        |
| ------------ | ---------------------- | --------------------------------------------- |
| 默认拷贝行为 | 浅拷贝（位拷贝）       | 赋值是引用                                    |
| 深拷贝       | 需手动实现拷贝构造函数 | `copy.deepcopy()`                             |
| 拷贝构造函数 | 有（`T(const T&)`）    | 无，但可通过`__copy__`, `__deepcopy__` 自定义 |
| 内存管理     | 手动或智能指针         | 自动垃圾回收                                  |
| 性能         | 深拷贝可能慢           | 深拷贝递归，可能很慢                          |

---

## ✅ 六、如何自定义拷贝行为（高级）

你可以重写 `__copy__` 和 `__deepcopy__`：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">python</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>import</span><span> copy
</span>
<span></span>class MyClass:<span>
</span><span>    </span>def __init__(self, x, y):<span>
</span>        self.x = x
        self.y = y

<span>    </span>def __copy__(self):<span>
</span><span>        </span><span># 自定义浅拷贝</span><span>
</span><span>        </span><span>return</span><span> MyClass(self.x, self.y)
</span>
<span>    </span>def __deepcopy__(self, memo):<span>
</span><span>        </span><span># 自定义深拷贝</span><span>
</span><span>        </span><span>return</span><span> MyClass(copy.deepcopy(self.x, memo), copy.deepcopy(self.y, memo))</span></code></pre></div></div></pre>

---

## ✅ 七、总结


| 问题                          | 答案                                          |
| ----------------------------- | --------------------------------------------- |
| **Python 有拷贝构造函数吗？** | ❌ 没有 C++ 那种语法，但有类似语义            |
| **Python 的浅拷贝是啥？**     | `copy.copy()`：复制最外层，嵌套对象共享       |
| **Python 的深拷贝是啥？**     | `copy.deepcopy()`：递归复制所有层级，完全独立 |
| **默认赋值 `=` 是拷贝吗？**   | ❌ 不是，只是引用（指针）                     |
| **什么时候用深拷贝？**        | 当对象包含可变嵌套结构（如 list of lists）时  |

---

### 🎯 最终口诀：

> **“Python 中：**
>
> * `=` 是**引用**
> * `copy.copy()` 是**浅拷贝**
> * `copy.deepcopy()` 是**深拷贝**
> * 嵌套可变对象，必须用 `deepcopy`”



# C++ 箭头操作符


## 🎯 一、C++ 箭头操作符（`->`）详解

### ✅ 基本概念

**箭头操作符 `->`** 是用于通过 **指针访问对象成员** 的运算符。

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>T* ptr = &obj;
</span><span>ptr->member;  </span><span>// 等价于 (*ptr).member</span></code></pre></div></div></pre>

> ⚠️ 注意：`ptr` 必须是一个指向对象的指针，不能直接对对象使用 `->`。

---

## 🔍 二、1. 基本用法：通过指针调用成员函数或访问成员变量

### 📌 图片中的例子：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code>class Entity {<span>
</span><span></span><span>public</span><span>:
</span><span>    </span>void Print() const <span>{ </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"Hello!"</span><span> << </span><span>std</span><span>::</span><span>endl</span><span>; }
</span>};

<span></span>int main() <span>{
</span>    Entity e;
    Entity* ptr = &e;

<span>    e.Print();        </span><span>// 直接调用</span><span>
</span><span>    ptr->Print();     </span><span>// 通过指针调用</span><span>
</span><span>    (*ptr).Print();   </span><span>// 等价写法，但更繁琐</span><span>
</span>}</code></pre></div></div></pre>

### ✅ 为什么用 `->`？

* 更简洁
* 避免括号优先级问题
* 是 C++ 的标准语法

> 💡 `ptr->Print()` 实际上是 `(*ptr).Print()` 的快捷方式。


## 三、2. 箭头操作符重载（Operator Overloading）

### 📌 场景：实现智能指针类

假设我们有一个 `ScopedPtr` 类，封装了堆分配的对象：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code>class Entity {<span>
</span><span></span><span>public</span><span>:
</span><span>    </span>void Print() const <span>{ </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"Hello from Entity!"</span><span> << </span><span>std</span><span>::</span><span>endl</span><span>; }
</span>};

<span></span>class ScopedPtr {<span>
</span><span></span><span>private</span><span>:
</span>    Entity* m_Obj;

<span></span><span>public</span><span>:
</span>    ScopedPtr(Entity* entity) : m_Obj(entity) {}
<span>    ~ScopedPtr() { </span><span>delete</span><span> m_Obj; }
</span>
<span>    </span><span>// 重载 -> 操作符</span><span>
</span><span>    Entity* </span><span>operator</span><span>->() {
</span><span>        </span><span>return</span><span> m_Obj;
</span>    }
};</code></pre></div></div></pre>

### ✅ 使用方式：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code>int main() <span>{
</span><span>    ScopedPtr entity = </span><span>new</span><span> Entity();
</span><span>    entity->Print();  </span><span>// ✅ 正常运行！</span><span>
</span><span>    </span><span>return</span><span> </span>0<span>;
</span>}</code></pre></div></div></pre>

### 🔥 关键点：

* `operator->()` 返回一个指向 `Entity` 的指针
* C++ 会自动链式调用：`entity->Print()` → 先调用 `operator->()` 返回 `m_Obj`，再调用 `m_Obj->Print()`
* 这样可以让自定义类像普通指针一样使用


## 四、3. 高级技巧：利用空指针获取成员偏移量

### 📌 图片中的“彩蛋”：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line" data-spm-anchor-id="5176.28103460.0.i16.5e842e317tzBAH"></use></svg></span></div></div></div><pre><code data-spm-anchor-id="5176.28103460.0.i15.5e842e317tzBAH">struct Vector3 {<span>
</span><span>    </span><span>float</span><span> x, y, z;
</span>};

<span></span><span>int</span><span> offset = (</span><span>int</span><span>)&((Vector3*)</span>0<span>)->x;
</span><span></span><span>std</span><span>::</span><span>cout</span><span> << offset << </span><span>std</span><span>::</span><span>endl</span><span>;  </span><span>// 输出: 0</span></code></pre></div></div></pre>

### ✅ 分步解释：


| 表达式              | 含义                                       |
| ------------------- | ------------------------------------------ |
| `(Vector3*)0`       | 将整数 0 强制转换为`Vector3*` 类型的空指针 |
| `((Vector3*)0)->x`  | 访问该“空指针”所指向的`x` 成员           |
| `&((Vector3*)0)->x` | 获取`x` 成员的地址（虽然指针是空的）       |
| `(int)&(...)`       | 将地址转为整数，得到偏移量                 |

> ✅ 结果：`x` 的偏移量是 0，`y` 是 4，`z` 是 8（因为 `float` 是 4 字节）

### ✅ 完整代码演示：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>#</span>include<span> </span><iostream><span>
</span>
<span></span>struct Vector3 {<span>
</span><span>    </span><span>float</span><span> x, y, z;
</span>};

<span></span>int main() <span>{
</span><span>    </span><span>int</span><span> offset_x = (</span><span>int</span><span>)&((Vector3*)</span>0<span>)->x;
</span><span>    </span><span>int</span><span> offset_y = (</span><span>int</span><span>)&((Vector3*)</span>0<span>)->y;
</span><span>    </span><span>int</span><span> offset_z = (</span><span>int</span><span>)&((Vector3*)</span>0<span>)->z;
</span>
<span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"x offset: "</span><span> << offset_x << </span><span>std</span><span>::</span><span>endl</span><span>;  </span><span>// 0</span><span>
</span><span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"y offset: "</span><span> << offset_y << </span><span>std</span><span>::</span><span>endl</span><span>;  </span><span>// 4</span><span>
</span><span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"z offset: "</span><span> << offset_z << </span><span>std</span><span>::</span><span>endl</span><span>;  </span><span>// 8</span><span>
</span>
<span>    </span><span>return</span><span> </span>0<span>;
</span>}</code></pre></div></div></pre>

### ❗️ 重要说明：

* 这个技巧依赖于 C++ 的内存布局规则
* 虽然 `((Vector3*)0)` 是空指针，但 **只用于获取偏移量，不实际访问内存**
* 是一种“合法的未定义行为”（undefined behavior），但大多数编译器支持
* 常用于 **序列化、反射、内存映射** 等底层编程

---

## ✅ 五、总结图解

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">text</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>普通用法：
</span>Entity* ptr = &e;
<span>ptr->Print();  → 等价于 (*ptr).</span><span>Print</span><span>()
</span>
重载用法：
<span>ScopedPtr sp(</span><span>new</span><span> Entity());
</span>sp->Print();   → 调用 operator->() 返回指针，再调用方法

偏移量技巧：
<span>((Vector3*)</span>0<span>)->x → 获取 x 成员的内存偏移量（</span>0<span>字节）</span></code></pre></div></div></pre>

---

## ✅ 六、完整可运行代码（整合所有知识点）

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>#</span>include<span> </span><iostream><span>
</span>
<span></span><span>// 1. 基本结构体</span><span>
</span><span></span>struct Vector3 {<span>
</span><span>    </span><span>float</span><span> x, y, z;
</span>};

<span></span><span>// 2. 实体类</span><span>
</span><span></span>class Entity {<span>
</span><span></span><span>public</span><span>:
</span><span>    </span>void Print() const <span>{ </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"Hello from Entity!"</span><span> << </span><span>std</span><span>::</span><span>endl</span><span>; }
</span>};

<span></span><span>// 3. 智能指针类（重载 ->）</span><span>
</span><span></span>class ScopedPtr {<span>
</span><span></span><span>private</span><span>:
</span>    Entity* m_Obj;

<span></span><span>public</span><span>:
</span>    ScopedPtr(Entity* entity) : m_Obj(entity) {}
<span>    ~ScopedPtr() { </span><span>delete</span><span> m_Obj; }
</span>
<span>    Entity* </span><span>operator</span><span>->() {
</span><span>        </span><span>return</span><span> m_Obj;
</span>    }
};

<span></span><span>// 4. 主函数</span><span>
</span><span></span>int main() <span>{
</span><span>    </span><span>// 示例1：基本箭头操作符</span><span>
</span>    Entity e;
    Entity* ptr = &e;
    ptr->Print();

<span>    </span><span>// 示例2：箭头操作符重载</span><span>
</span><span>    ScopedPtr scoped_entity = </span><span>new</span><span> Entity();
</span><span>    scoped_entity->Print();  </span><span>// 通过重载的 -> 调用</span><span>
</span>
<span>    </span><span>// 示例3：获取成员偏移量</span><span>
</span><span>    </span><span>int</span><span> offset_x = (</span><span>int</span><span>)&((Vector3*)</span>0<span>)->x;
</span><span>    </span><span>int</span><span> offset_y = (</span><span>int</span><span>)&((Vector3*)</span>0<span>)->y;
</span><span>    </span><span>int</span><span> offset_z = (</span><span>int</span><span>)&((Vector3*)</span>0<span>)->z;
</span>
<span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"x offset: "</span><span> << offset_x << </span><span>std</span><span>::</span><span>endl</span><span>;
</span><span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"y offset: "</span><span> << offset_y << </span><span>std</span><span>::</span><span>endl</span><span>;
</span><span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"z offset: "</span><span> << offset_z << </span><span>std</span><span>::</span><span>endl</span><span>;
</span>
<span>    </span><span>return</span><span> </span>0<span>;
</span>}</code></pre></div></div></pre>

---

## ✅ 七、输出结果

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">text</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>Hello </span><span>from</span><span> Entity!
</span><span>Hello </span><span>from</span><span> Entity!
</span><span>x offset: </span>0<span>
</span><span>y offset: </span>4<span>
</span><span>z offset: </span>8</code></pre></div></div></pre>

---

## ✅ 八、关键总结


| 概念       | 说明                                       |
| ---------- | ------------------------------------------ |
| `->` 用法  | 通过指针访问成员，等价于`(*ptr).member`    |
| 重载`->`   | 可让自定义类像指针一样使用，常见于智能指针 |
| 空指针技巧 | 获取成员偏移量，用于底层开发               |
| 安全性     | 重载`->` 时要返回有效指针，避免悬空指针    |

---

## 🎯 最终口诀

> **“箭头 `->` 是指针的门钥匙，****重载它，让你的类像指针一样灵活，****空指针也能算偏移，这是 C++ 的高级魔法！**
>
