# 复制与拷贝构造函数


## 一、核心概念总览


| 概念                       | 说明                                               |
| -------------------------- | -------------------------------------------------- |
| **拷贝（Copy）**           | 将一个对象的数据复制到另一个对象中。               |
| **拷贝构造函数**           | 当用一个已存在的对象初始化另一个新对象时自动调用。 |
| **浅拷贝（Shallow Copy）** | 只复制指针，两个对象共享同一块内存。危险！         |
| **深拷贝（Deep Copy）**    | 复制数据本身，每个对象拥有独立内存。安全！         |
| **引用传递**               | 避免不必要的复制，提高性能。                       |


## 二、详细解释 + 图解说明

### 1. 拷贝 vs 指针拷贝

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>int</span><span> a = </span>2<span>;
</span><span></span><span>int</span><span> b = a;  </span><span>// ✅ 拷贝：a 和 b 是两个独立变量</span></code></pre></div></div></pre>

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>Vector2* a = </span><span>new</span><span> Vector2();
</span><span>Vector2* b = a;  </span><span>// ❌ 指针拷贝：b 和 a 指向同一内存</span><span>
</span><span>b->x = </span>5<span>;        </span><span>// 修改 b，a 也会变！</span></code></pre></div></div></pre>

> 💡 **结论**：`T obj1 = obj2;` 是拷贝，`T* ptr1 = ptr2;` 是指针赋值，不是拷贝！

---

### 2. 拷贝构造函数（Copy Constructor）

当用一个对象初始化另一个对象时，会调用拷贝构造函数：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>String</span><span> str1 = </span><span>"Cherno"</span><span>;
</span><span></span><span>String</span><span> str2 = str1;  </span><span>// ✅ 调用拷贝构造函数</span></code></pre></div></div></pre>

如果类中有动态内存（如 `char*`），C++ 默认提供的是 **浅拷贝**，这会导致问题！

---

### 3. 浅拷贝的问题（图片中的崩溃原因）

#### 🔥 问题场景：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code>class String {<span>
</span><span></span><span>private</span><span>:
</span><span>    </span><span>char</span><span>* m_Buffer;
</span><span>    </span><span>unsigned</span><span> </span><span>int</span><span> m_Size;
</span><span></span><span>public</span><span>:
</span><span>    String(</span><span>const</span><span> </span><span>char</span><span>* </span><span>string</span><span>) {
</span><span>        m_Size = </span><span>strlen</span><span>(</span><span>string</span><span>);
</span><span>        m_Buffer = </span><span>new</span><span> </span><span>char</span><span>[m_Size];  </span><span>// ⚠️ 忘记 +1，且没加 '\0'</span><span>
</span><span>        </span><span>memcpy</span><span>(m_Buffer, </span><span>string</span><span>, m_Size);
</span>    }
    ~String() {
<span>        </span><span>delete</span><span>[] m_Buffer;  </span><span>// 析构函数</span><span>
</span>    }
};</code></pre></div></div></pre>

#### 👉 创建两个对象：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>String</span><span> </span><span>string</span><span> = </span><span>"Cherno"</span><span>;
</span><span></span><span>String</span><span> second = </span><span>string</span><span>;  </span><span>// ✅ 拷贝构造函数被调用</span></code></pre></div></div></pre>

默认拷贝构造函数是**浅拷贝**，即：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>String</span><span>(</span><span>const</span><span> </span><span>String</span><span>& other) : m_Buffer(other.m_Buffer), </span>m_Size(other.m_Size)<span> {}</span></code></pre></div></div></pre>

结果：

* `string.m_Buffer` 和 `second.m_Buffer` 指向**同一块内存**
* 两个对象都持有同一个 `char*`
* 程序结束时，两个析构函数都会调用 `delete[] m_Buffer` → **双重释放！崩溃！**

> 🔥 这就是图片中“wntdll.pdb not loaded”崩溃的原因！

---

### 4. 解决方案：深拷贝（Deep Copy）

我们要让每个对象都有自己的内存！

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>String</span><span>(</span><span>const</span><span> </span><span>String</span><span>& other)
</span><span>    : </span>m_Size(other.m_Size)<span>
</span>{
<span>    m_Buffer = </span><span>new</span><span> char[m_Size + </span>1<span>];  </span><span>// 分配新内存</span><span>
</span><span>    memcpy(m_Buffer, other.m_Buffer, m_Size + </span>1<span>);  </span><span>// 复制内容</span><span>
</span>}</code></pre></div></div></pre>

✅ 此时 `string` 和 `second` 各自拥有独立的内存，修改其中一个不会影响另一个。

---

### 5. 引用传递 vs 值传递（避免多余拷贝）

#### ❌ 值传递（引发多次拷贝）：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code>void PrintString(String string) <span>{  </span><span>// 值传递 → 触发拷贝构造</span><span>
</span><span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>string</span><span> << </span><span>std</span><span>::</span><span>endl</span><span>;
</span>}</code></pre></div></div></pre>

* 函数参数传入时：一次拷贝
* 函数内部使用时：可能再拷贝一次
* 性能差，尤其对大对象

#### ✅ 引用传递（推荐）：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code>void PrintString(const String& string) <span>{  </span><span>// const 引用 → 不拷贝</span><span>
</span><span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>string</span><span> << </span><span>std</span><span>::</span><span>endl</span><span>;
</span>}</code></pre></div></div></pre>

* 无拷贝，直接访问原对象
* 更高效，更安全


## 三、完整可运行代码（含所有知识点）

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code data-spm-anchor-id="5176.28103460.0.i30.5e842e317ELiV5"><span>#</span>include<span> </span><iostream><span>
</span><span></span><span>#</span>include<span> </span><cstring><span>
</span>
<span></span>class String {<span>
</span><span></span><span>private</span><span>:
</span><span>    </span><span>char</span><span>* m_Buffer;
</span><span>    </span><span>unsigned</span><span> </span><span>int</span><span> m_Size;
</span>
<span></span><span>public</span><span>:
</span><span>    </span><span>// 构造函数</span><span>
</span><span>    String(</span><span>const</span><span> </span><span>char</span><span>* </span><span>string</span><span>) {
</span><span>        m_Size = </span><span>strlen</span><span>(</span><span>string</span><span>);
</span><span>        m_Buffer = </span><span>new</span><span> </span><span>char</span><span>[m_Size + </span>1<span>];  </span><span>// +1 为 '\0'</span><span>
</span><span>        </span><span>memcpy</span><span>(m_Buffer, </span><span>string</span><span>, m_Size + </span>1<span>);
</span>    }

<span>    </span><span>// 拷贝构造函数（深拷贝）</span><span>
</span><span>    String(</span><span>const</span><span> String& other)
</span>        : m_Size(other.m_Size)
    {
<span>        m_Buffer = </span><span>new</span><span> </span><span>char</span><span>[m_Size + </span>1<span>];
</span><span>        </span><span>memcpy</span><span>(m_Buffer, other.m_Buffer, m_Size + </span>1<span>);
</span>    }

<span>    </span><span>// 析构函数</span><span>
</span>    ~String() {
<span>        </span><span>delete</span><span>[] m_Buffer;
</span>    }

<span>    </span><span>// 重载输出运算符</span><span>
</span><span>    </span><span>friend</span><span> </span><span>std</span><span>::ostream& </span><span>operator</span><span><<(</span><span>std</span><span>::ostream& stream, </span><span>const</span><span> String& </span><span>string</span><span>) {
</span><span>        stream << </span><span>string</span><span>.m_Buffer;
</span><span>        </span><span>return</span><span> stream;
</span>    }

<span>    </span><span>// 重载 [] 操作符</span><span>
</span><span>    </span><span>char</span><span>& </span><span>operator</span><span>[](</span><span>unsigned</span><span> </span><span>int</span><span> index) {
</span><span>        </span><span>return</span><span> m_Buffer[index];
</span>    }
};

<span></span><span>// 打印函数：使用 const 引用避免拷贝</span><span>
</span><span></span>void PrintString(const String& string) <span>{
</span><span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>string</span><span> << </span><span>std</span><span>::</span><span>endl</span><span>;
</span>}

<span></span>int main() <span>{
</span><span>    String </span><span>string</span><span> = </span><span>"Cherno"</span><span>;
</span><span>    String second = </span><span>string</span><span>;  </span><span>// 调用拷贝构造函数（深拷贝）</span><span>
</span>
<span>    second[</span>2<span>] = </span><span>'a'</span><span>;  </span><span>// 修改 second，不影响 string</span><span>
</span>
<span>    PrintString(</span><span>string</span><span>);  </span><span>// 输出: Cherno</span><span>
</span><span>    PrintString(second); </span><span>// 输出: Charo</span><span>
</span>
<span>    </span><span>std</span><span>::</span><span>cin</span><span>.get();  </span><span>// 等待输入</span><span>
</span><span>    </span><span>return</span><span> </span>0<span>;
</span>}</code></pre></div></div></pre>

---

## 📊 四、运行结果

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">text</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>Cherno
</span>Charo</code></pre></div></div></pre>

> ✅ 成功！没有崩溃，没有内存泄漏，修改 `second` 不影响 `string`。


## 五、总结图解（文字版）

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">text</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>浅拷贝（错误）：
</span><span>   </span><span>string</span><span>.m_Buffer → [内存块] ← second.m_Buffer
</span>                    ↑
<span>                   共享内存 → 两个析构函数都 </span><span>delete</span><span> → 双重释放 → 崩溃！
</span>
深拷贝（正确）：
<span>   </span><span>string</span><span>.m_Buffer → [内存块A]
</span>   second.m_Buffer → [内存块B]
                    ↑
<span>                   独立内存 → 各自 </span><span>delete</span><span> → 安全！
</span>
引用传递：
<span>   PrintString(</span><span>const</span><span> String& </span><span>string</span><span>) → 直接访问原始对象，不拷贝</span></code></pre></div></div></pre>

---

## ✅ 六、最佳实践建议


| 场景                    | 推荐方式                            |
| ----------------------- | ----------------------------------- |
| 类包含动态内存（`new`） | ✅ 必须实现深拷贝构造函数和析构函数 |
| 传递大对象给函数        | ✅ 使用`const T&` 引用传递          |
| 不允许拷贝              | ✅ 将拷贝构造函数声明为`= delete`   |
| 想避免复制              | ✅ 使用`std::move` 或智能指针       |
