# C++ 对象生存期（栈作用域生存期）全面总结

### 一、核心概念（图片1、2）

#### 1. **栈作用域生存期的本质**

* **类比**：就像把书放到书架上，作用域结束时书被扔掉（图片1的书籍比喻）
* **自动管理**：栈上对象在作用域结束时自动销毁
* **确定性**：生存期完全由代码结构决定，可预测

#### 2. **基本示例（图片1代码）**

<pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">class Entity {
public:
    Entity() { std::cout << "Created Entity\n"; }
    ~Entity() { std::cout << "Destroyed Entity\n"; }
};

int main() {
    { // 开始作用域
        Entity e;  // 栈上创建
    } // 结束作用域，e自动销毁
  
    return 0;
}</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>

**输出**：

<pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-markdown">Created Entity
Destroyed Entity</code></div></div></pre></div></pre>

## 二、常见问题与陷阱（图片2、3）

### 1. **返回局部变量指针的错误（图片2）**

<pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">// ❌ 错误示例
int* CreateArray() {
    int array[50];  // 栈上分配
    return array;   // 返回指向即将销毁内存的指针！
}

int main() {
    int* a = CreateArray();  // 悬空指针！
    // a指向的内存已被释放
}</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>

### 2. **正确解决方案（图片3）**

#### 方案A：堆上分配

<pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">int* CreateArray() {
    int* array = new int[50];  // 堆上分配
    return array;  // 安全：生存期不受作用域限制
}

int main() {
    int* a = CreateArray();
    // 使用后必须手动释放！
    delete[] a;
}</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>

#### 方案B：传入外部数组

<pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">void CreateArray(int* array) {
    // 填充已存在的数组
}

int main() {
    int array[50];  // 在调用者作用域内
    CreateArray(array);  // 传递指针，不涉及生存期问题
}</code></div><div class="hyc-code-scrollbar__track"><br class="Apple-interchange-newline"/></div></div></pre></div></pre>

## 三、利用栈生存期的智能模式（图片4）

### 1. **作用域指针（Scoped Pointer）**

<pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">class ScopedPtr {
private:
    Entity* m_Ptr;
public:
    ScopedPtr(Entity* ptr) : m_Ptr(ptr) {}
    ~ScopedPtr() { delete m_Ptr; }  // 自动释放！
};

int main() {
    {
        ScopedPtr e = new Entity();  // 堆分配，但自动管理
    } // 离开作用域时自动调用delete
}</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>

**输出**：

<pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-markdown">Created Entity
Destroyed Entity  // 自动调用！</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>

### 2. **实际应用场景（图片4）**

#### 🕒 计时器（Timer）

<pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">class Timer {
public:
    Timer() { start = std::chrono::high_resolution_clock::now(); }
    ~Timer() {
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = end - start;
        std::cout << "耗时: " << duration.count() << "ns\n";
    }
private:
    std::chrono::time_point<std::chrono::high_resolution_clock> start;
};

void expensiveFunction() {
    Timer timer;  // 构造时开始计时
    // 执行昂贵操作...
} // 析构时自动打印耗时</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>

#### 🔒 互斥锁（Mutex Locking）

<pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">class ScopedLock {
public:
    ScopedLock(std::mutex& mtx) : mutex(mtx) { mutex.lock(); }
    ~ScopedLock() { mutex.unlock(); }
private:
    std::mutex& mutex;
};

std::mutex g_mutex;

void threadSafeFunction() {
    ScopedLock lock(g_mutex);  // 自动加锁
    // 临界区代码...
} // 自动解锁，即使异常也能保证解锁！</code></div></div></pre></div></pre>

## 四、栈生存期 vs 堆生存期对比


| **特性**     | **栈生存期**       | **堆生存期**       |
| ------------ | ------------------ | ------------------ |
| **管理方式** | 自动（作用域结束） | 手动（new/delete） |
| **性能**     | 快速（移动栈指针） | 较慢（系统调用）   |
| **安全性**   | 高（无内存泄漏）   | 低（需手动管理）   |
| **灵活性**   | 固定大小/生存期    | 动态大小/生存期    |
| **适用场景** | 局部临时对象       | 长期存在的大对象   |

---

## 💡 五、现代C++的最佳实践

### 1. **优先使用栈对象**

<pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">// ✅ 推荐：栈上小对象
void processData() {
    std::vector<int> data(1000);  // 栈上vector（元素在堆，控制块在栈）
    // 使用数据...
} // 自动清理，无内存泄漏风险</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>

### 2. **使用智能指针替代裸new/delete**

<pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">#include <memory>

void modernApproach() {
    // 类似图片4的ScopedPtr，但更安全
    auto ptr = std::make_unique<Entity>();  // C++11智能指针
    // 无需手动delete，离开作用域自动释放
}</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>

### 3. **RAII（资源获取即初始化）模式**

<pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-cpp">class FileHandler {
public:
    FileHandler(const std::string& filename) : file(std::fopen(filename.c_str(), "r")) {}
    ~FileHandler() { if (file) std::fclose(file); }
private:
    FILE* file;
};

void readFile() {
    FileHandler fh("data.txt");  // 自动打开文件
    // 使用文件...
} // 自动关闭文件！</code></div></div></pre></div></pre>

## 六、关键总结

### 1. **栈生存期的核心优势**

* **自动管理**：避免内存泄漏
* **性能优异**：分配/释放极快
* **异常安全**：即使抛出异常也能保证清理
* **可预测性**：生存期与代码结构对应

### 2. **适用场景**

* **短生命周期对象**：函数内临时变量
* **资源管理类**：锁、文件句柄、计时器
* **性能敏感代码**：避免不必要的堆分配

### 3. **设计原则**

> "基于栈的变量在离开作用域时自动销毁，这一特性是C++ RAII理念的基石，也是编写安全、高效C++代码的关键。"

### 4. **现代发展**

图片4中的`ScopedPtr`实际上是现代`std::unique_ptr`的原型，体现了C++"资源管理应与对象生存期绑定"的核心哲学。

# C++ 智能指针详解：`unique_ptr`, `shared_ptr`, `weak_ptr`

> **目标**：理解三种智能指针的作用、原理和使用方法，避免内存泄漏。

## ✅ 一、什么是智能指针？

智能指针是 C++ 中的一种**类模板**，它封装了原始指针（`T*`），并自动管理动态分配的内存。

### ✅ 核心思想：

* 当智能指针超出作用域时，自动调用 `delete`。
* 避免手动 `new/delete` 导致的内存泄漏或悬空指针。
* 实现 RAII（Resource Acquisition Is Initialization）——资源获取即初始化。

## ✅ 二、三大智能指针对比


| 类型         | 所有权     | 可复制？    | 引用计数       | 使用场景           |
| ------------ | ---------- | ----------- | -------------- | ------------------ |
| `unique_ptr` | 唯一所有权 | ❌ 不可复制 | 无             | 单一所有者，栈对象 |
| `shared_ptr` | 共享所有权 | ✅ 可复制   | 有（引用计数） | 多个对象共享资源   |
| `weak_ptr`   | 无所有权   | ✅ 可复制   | 有（弱引用）   | 防止循环引用       |

---

## ✅ 三、详细说明与代码示例

### 🔹 1. `unique_ptr` —— 独占式智能指针

#### ✅ 特点：

* 一个对象只能被一个 `unique_ptr` 拥有。
* 不可复制，但可以移动（`std::move`）。
* 自动释放内存，异常安全。
* 性能高，无额外开销（除了指针本身）。

#### ✅ 创建方式：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>#</span>include<span> </span><iostream><span>
</span><span></span><span>#</span>include<span> </span><memory><span>
</span>
<span></span>class Entity {<span>
</span><span></span><span>public</span><span>:
</span><span>    Entity() { </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"Created Entity\n"</span><span>; }
</span><span>    ~Entity() { </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"Destroyed Entity\n"</span><span>; }
</span><span>    </span>void Print() const <span>{ </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"Entity is alive!\n"</span><span>; }
</span>};

<span></span>int main() <span>{
</span><span>    </span><span>// 方法1：直接构造</span><span>
</span><span>    </span><span>std</span><span>::</span><span>unique_ptr</span><span><Entity> entity = </span><span>std</span><span>::make_unique<Entity>();
</span>    entity->Print();

<span>    </span><span>// 方法2：使用 move 转移所有权</span><span>
</span><span>    </span><span>auto</span><span> ptr1 = </span><span>std</span><span>::make_unique<Entity>();
</span><span>    </span><span>auto</span><span> ptr2 = </span><span>std</span><span>::move(ptr1); </span><span>// ptr1 变为空，ptr2 拥有对象</span><span>
</span>    ptr2->Print();

<span>    </span><span>// 错误：不能复制</span><span>
</span><span>    </span><span>// auto ptr3 = ptr2; // 编译错误！</span><span>
</span>
<span>    </span><span>return</span><span> </span>0<span>;
</span>}</code></pre></div></div></pre>

> 💡 推荐使用 `std::make_unique<T>()`，更安全、异常安全。

### 🔹 2. `shared_ptr` —— 共享式智能指针

#### ✅ 特点：

* 支持多个 `shared_ptr` 共享同一个对象。
* 使用**引用计数**：当引用计数为 0 时，自动销毁对象。
* 可以复制，适合多线程、容器中存储对象。

#### ✅ 创建方式：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>#</span>include<span> </span><iostream><span>
</span><span></span><span>#</span>include<span> </span><memory><span>
</span><span></span><span>#</span>include<span> </span><vector><span>
</span>
<span></span>class Entity {<span>
</span><span></span><span>public</span><span>:
</span><span>    Entity() { </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"Created Entity\n"</span><span>; }
</span><span>    ~Entity() { </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"Destroyed Entity\n"</span><span>; }
</span><span>    </span>void Print() const <span>{ </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"Entity is alive!\n"</span><span>; }
</span>};

<span></span>int main() <span>{
</span><span>    </span><span>auto</span><span> sharedEntity = </span><span>std</span><span>::make_shared<Entity>();
</span>
    {
<span>        </span><span>auto</span><span> e0 = sharedEntity;  </span><span>// 引用计数 +1</span><span>
</span><span>        </span><span>auto</span><span> e1 = sharedEntity;  </span><span>// 引用计数 +1</span><span>
</span>        e0->Print();
<span>    } </span><span>// e0, e1 出作用域，引用计数 -2</span><span>
</span>
<span>    </span><span>// 此时引用计数为 1，对象仍然存活</span><span>
</span>    sharedEntity->Print();

<span>    </span><span>return</span><span> </span>0<span>;
</span>}</code></pre></div></div></pre>

> ⚠️ 注意：`std::make_shared<T>()` 是推荐方式，比 `new T()` 更高效（一次内存分配）。

### 🔹 3. `weak_ptr` —— 弱引用智能指针

#### ✅ 特点：

* 不增加引用计数。
* 用于解决 `shared_ptr` 的**循环引用问题**。
* 不能直接解引用，必须先转换为 `shared_ptr`。
* 使用 `lock()` 检查是否仍有效。

#### ✅ 示例：防止循环引用

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>#</span>include<span> </span><iostream><span>
</span><span></span><span>#</span>include<span> </span><memory><span>
</span>
<span></span>class Child;<span>
</span><span></span>class Parent {<span>
</span><span></span><span>public</span><span>:
</span><span>    </span><span>std</span><span>::</span><span>shared_ptr</span><span><Child> child;
</span><span>    ~Parent() { </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"Parent destroyed\n"</span><span>; }
</span>};

<span></span>class Child {<span>
</span><span></span><span>public</span><span>:
</span><span>    </span><span>std</span><span>::weak_ptr<Parent> parent; </span><span>// 使用 weak_ptr</span><span>
</span><span>    ~Child() { </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"Child destroyed\n"</span><span>; }
</span>};

<span></span>int main() <span>{
</span><span>    </span><span>auto</span><span> parent = </span><span>std</span><span>::make_shared<Parent>();
</span><span>    </span><span>auto</span><span> child = </span><span>std</span><span>::make_shared<Child>();
</span>
    parent->child = child;
    child->parent = parent;

<span>    </span><span>// 此时 parent 和 child 彼此持有对方的 shared_ptr → 循环引用！</span><span>
</span><span>    </span><span>// 如果不使用 weak_ptr，引用计数永远不为 0，导致内存泄漏！</span><span>
</span>
<span>    </span><span>// 但是我们用了 weak_ptr，所以不会影响引用计数</span><span>
</span><span>    </span><span>// 当 parent 和 child 都出作用域后，会正常析构</span><span>
</span>
<span>    </span><span>return</span><span> </span>0<span>;
</span>}</code></pre></div></div></pre>

#### ✅ `weak_ptr` 的使用方式：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>auto</span><span> sharedEntity = </span><span>std</span><span>::make_shared<Entity>();
</span><span></span><span>std</span><span>::weak_ptr<Entity> weakEntity = sharedEntity;
</span>
<span></span><span>// 检查是否还有效</span><span>
</span><span></span><span>if</span><span> (</span><span>auto</span><span> ptr = weakEntity.lock()) {
</span><span>    ptr->Print();  </span><span>// 安全访问</span><span>
</span><span>} </span><span>else</span><span> {
</span><span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"Entity has been destroyed\n"</span><span>;
</span>}</code></pre></div></div></pre>

## ✅ 四、智能指针总结表


| 指针类型     | 是否独占 | 是否可复制 | 是否增加引用计数 | 是否支持异常安全 | 适用场景               |
| ------------ | -------- | ---------- | ---------------- | ---------------- | ---------------------- |
| `unique_ptr` | ✅ 是    | ❌ 否      | ❌ 否            | ✅ 是            | 单一拥有者，栈对象     |
| `shared_ptr` | ❌ 否    | ✅ 是      | ✅ 是            | ✅ 是            | 多个对象共享资源       |
| `weak_ptr`   | ❌ 否    | ✅ 是      | ❌ 否            | ✅ 是            | 防止循环引用，临时观察 |

---

## ✅ 五、最佳实践建议

1. ✅ **优先使用 `unique_ptr`**，除非需要共享。
2. ✅ **使用 `make_unique` / `make_shared`**，避免裸 `new`。
3. ✅ **避免 `shared_ptr` 的循环引用**，用 `weak_ptr` 断开。
4. ✅ **不要混合使用原始指针和智能指针**。
5. ✅ **尽量在栈上创建对象**，减少堆分配。

## ✅ 六、完整可运行代码（综合示例）

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>#</span>include<span> </span><iostream><span>
</span><span></span><span>#</span>include<span> </span><memory><span>
</span><span></span><span>#</span>include<span> </span><vector><span>
</span>
<span></span>class Entity {<span>
</span><span></span><span>public</span><span>:
</span><span>    Entity() { </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"Created Entity\n"</span><span>; }
</span><span>    ~Entity() { </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"Destroyed Entity\n"</span><span>; }
</span><span>    </span>void Print() const <span>{ </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"Entity is alive!\n"</span><span>; }
</span>};

<span></span>int main() <span>{
</span><span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"=== unique_ptr ===\n"</span><span>;
</span>    {
<span>        </span><span>auto</span><span> unique = </span><span>std</span><span>::make_unique<Entity>();
</span>        unique->Print();
<span>    } </span><span>// unique 出作用域，自动销毁</span><span>
</span>
<span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"\n=== shared_ptr ===\n"</span><span>;
</span>    {
<span>        </span><span>auto</span><span> shared = </span><span>std</span><span>::make_shared<Entity>();
</span><span>        </span><span>auto</span><span> shared2 = shared;  </span><span>// 共享所有权</span><span>
</span>        shared->Print();
<span>    } </span><span>// 引用计数为0，自动销毁</span><span>
</span>
<span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"\n=== weak_ptr ===\n"</span><span>;
</span>    {
<span>        </span><span>auto</span><span> shared = </span><span>std</span><span>::make_shared<Entity>();
</span><span>        </span><span>std</span><span>::weak_ptr<Entity> weak = shared;
</span>
<span>        </span><span>if</span><span> (</span><span>auto</span><span> ptr = weak.lock()) {
</span>            ptr->Print();
        }

<span>        </span><span>// shared 出作用域，对象被销毁</span><span>
</span><span>        </span><span>// 再次检查 weak</span><span>
</span><span>        </span><span>if</span><span> (</span><span>auto</span><span> ptr = weak.lock()) {
</span>            ptr->Print();
<span>        } </span><span>else</span><span> {
</span><span>            </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"Entity already destroyed\n"</span><span>;
</span>        }
    }

<span>    </span><span>return</span><span> </span>0<span>;
</span>}</code></pre></div></div></pre>

### 📌 输出结果：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">text</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>=== unique_ptr ===
</span>Created Entity
<span>Entity </span><span>is</span><span> alive!
</span>Destroyed Entity

=== shared_ptr ===
Created Entity
<span>Entity </span><span>is</span><span> alive!
</span>Destroyed Entity

=== weak_ptr ===
Created Entity
<span>Entity </span><span>is</span><span> alive!
</span>Entity already destroyed
Destroyed Entity</code></pre></div></div></pre>

---

## ✅ 七、常见误区提醒


| 误区                                 | 说明                           |
| ------------------------------------ | ------------------------------ |
| `shared_ptr` 直接赋值给 `unique_ptr` | ❌ 不允许，所有权冲突          |
| `unique_ptr` 复制                    | ❌ 编译错误，应使用`std::move` |
| 忘记`make_shared`                    | ❌ 两次内存分配，效率低        |
| 循环引用未用`weak_ptr`               | ❌ 内存泄漏                    |

---

## ✅ 八、小结

> **智能指针不是“万能药”，而是“现代 C++ 的安全卫士”**。

* `unique_ptr`：你的第一选择，简单安全。
* `shared_ptr`：当你需要共享时，记得防循环。
* `weak_ptr`：用来“观察”而不“拥有”。

# 创建方式的区别

## 一、为什么推荐 `std::make_unique<T>()`？比 `new` 好在哪？

### ❌ 传统写法（不推荐）：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>auto</span><span> ptr = </span><span>std</span><span>::</span><span>unique_ptr</span><span><Entity>(</span><span>new</span><span> Entity());</span></code></pre></div></div></pre>

### ✅ 推荐写法：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>auto</span><span> ptr = </span><span>std</span><span>::make_unique<Entity>();</span></code></pre></div></div></pre>

### ✅ 优势1：**异常安全（Exception Safety）**

#### 问题场景：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>// 假设有多个参数的函数</span><span>
</span><span></span>void func(std::unique_ptr<A>, std::unique_ptr<B>)<span>;
</span>
<span>func(</span><span>std</span><span>::</span><span>unique_ptr</span><span><A>(</span><span>new</span><span> A()), </span><span>std</span><span>::</span><span>unique_ptr</span><span><B>(</span><span>new</span><span> B()));</span></code></pre></div></div></pre>

[C++ **不保证参数求值顺序**！可能的执行顺序：]()

1. [`new A()` → 成功，返回指针]()
2. [`new B()` → 成功，返回指针]()
3. [构造 `unique_ptr<B>` → 成功]()
4. [构造 `unique_ptr<A>` → 抛异常！💥]()

[此时：]()

* [`A` 的内存已分配（`new A()` 成功）]()
* [但 `unique_ptr<A>` 没构造成功 → **内存泄漏！**]()

[👉 因为 `unique_ptr` 没拿到所有权，`delete` 不会被调用。]()

#### [✅ `make_unique` 解决了这个问题：]()

[`std::make_unique<A>()` 是一个**原子操作**：]()

* [要么成功返回 `unique_ptr<A>`]()
* [要么抛异常，但不会留下“半成品”]()

[所以不会泄漏。]()

> [🎯 **结论：`make_unique` 是异常安全的，`new` + 构造 `unique_ptr` 不是。**]()

### [✅ 优势2：**简洁、避免重复类型**]()

[更短、更清晰、不易出错。]()

---

### [✅ 优势3：**防止构造时的资源泄漏**]()

[`make_unique` 内部使用完美转发（perfect forwarding），确保对象构造和指针包装是“原子”的。]()

## [二、为什么 `std::make_shared<T>()` 比 `new T()` 更高效？]()

[这是个**性能问题**，关键在于：**内存分配次数**。]()

### [❌ 传统写法：]()

[这个操作需要 **两次内存分配**：]()


| 步骤  | 分配内容          | 说明                                                          |
| ----- | ----------------- | ------------------------------------------------------------- |
| 1️⃣ | `new Entity()`    | 分配对象本身（比如 16 字节）                                  |
| 2️⃣ | `shared_ptr` 内部 | 分配**控制块（control block）**（存储引用计数、弱引用计数等） |

[👉 两次独立的 `malloc`，性能差，缓存不友好。]()

---

### [✅ `std::make_shared<T>()` 的优化：]()

[它会**一次性分配一块连续内存**，包含：]()

[👉 **一次内存分配，搞定对象和控制块**。]()

### [✅ 好处：]()


| 优势              | 说明                                     |
| ----------------- | ---------------------------------------- |
| ⚡ 更快           | 减少`malloc` 调用次数                    |
| 💾 更好缓存局部性 | 对象和控制块在内存中连续，CPU 缓存更友好 |
| 📉 减少内存碎片   | 一次分配，一次释放                       |

---

### [🔬 验证：`make_shared` 只分配一次]()

[输出：]()

[虽然你看不到内存分配，但底层确实只调用了一次 `operator new`（分配总大小 = `sizeof(Entity) + 控制块大小`）。]()

## [三、对比总结表]()


| 写法                   | 内存分配次数 | 异常安全              | 性能 | 推荐度      |
| ---------------------- | ------------ | --------------------- | ---- | ----------- |
| `shared_ptr<T>(new T)` | 2 次         | ❌ 不安全             | 较慢 | ❌ 不推荐   |
| `make_shared<T>()`     | 1 次         | ✅ 安全               | 更快 | ✅ 强烈推荐 |
| `unique_ptr<T>(new T)` | 1 次（对象） | ❌ 不安全（多参数时） | 正常 | ❌ 不推荐   |
| `make_unique<T>()`     | 1 次         | ✅ 安全               | 正常 | ✅ 强烈推荐 |

---

## [✅ 四、特殊情况：`make_shared` 的限制]()

[虽然 `make_shared` 很好，但有**两个限制**：]()

### [1. 不能自定义删除器（deleter）]()

### [2. 对象生命周期可能延长]()

* [`make_shared` 把对象和控制块放在一起。]()
* [即使引用计数为 0，**对象和控制块要一起释放**。]()
* [如果 `weak_ptr` 还存在，对象内存不能释放（即使没人用了）。]()

[👉 在内存敏感场景需注意。]()

---

## [✅ 五、最终结论：为什么推荐？]()


| 推荐语                   | 原因                               |
| ------------------------ | ---------------------------------- |
| **`make_unique` 更安全** | 避免异常导致的内存泄漏，代码更简洁 |
| **`make_shared` 更高效** | 一次内存分配，性能更好，缓存友好   |

---

### [🎯 最佳实践口诀：]()

> [**“能用 `make_unique` 就不用 `new`，
> 能用 `make_shared` 就不用 `shared_ptr(new T)`。”**]()

[这是现代 C++ 的**黄金准则**，能让你写出更安全、更高效的代码。]()

# [智能指针管理的是堆上的对象]()


## 一、智能指针的设计目的

智能指针（`unique_ptr`, `shared_ptr`, `weak_ptr`）的核心职责是：

> **自动管理动态分配的内存（即堆内存）的生命周期。**

而堆内存的特点是：

* 通过 `new` / `malloc` 分配
* 必须手动或自动 `delete` / `free`
* 生命周期不依赖作用域（不像栈变量）

所以，**智能指针就是为了解决“堆对象”的内存管理问题而存在的**。

---

## ✅ 二、智能指针如何创建对象？

### 1. `std::make_unique<T>()` 和 `std::make_shared<T>()`

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>auto</span><span> ptr1 = </span><span>std</span><span>::make_unique<Entity>();  </span><span>// 在堆上 new 一个 Entity</span><span>
</span><span></span><span>auto</span><span> ptr2 = </span><span>std</span><span>::make_shared<Entity>();  </span><span>// 在堆上 new 一个 Entity</span></code></pre></div></div></pre>

* 这两个函数内部都会调用 `new T(...)`。
* 对象被分配在**堆上**。
* 智能指针持有这个堆对象的指针，并在适当时候调用 `delete`。

👉 所以：**是的，对象在堆上。**

---

### 2. `shared_ptr` 也可以包装已有的堆对象

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>Entity* raw_ptr = </span><span>new</span><span> Entity();
</span><span></span><span>auto</span><span> sp = </span><span>std</span><span>::</span><span>shared_ptr</span><span><Entity>(raw_ptr);  </span><span>// sp 管理这个堆对象</span></code></pre></div></div></pre>

* `raw_ptr` 指向堆对象。
* `sp` 接管所有权，后续自动释放。

---

## ✅ 三、那能不能让智能指针管理栈对象？

### ❌ 直接管理栈对象是**危险且错误的**！

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>Entity entity;  </span><span>// 栈对象</span><span>
</span><span></span><span>auto</span><span> sp = </span><span>std</span><span>::</span><span>shared_ptr</span><span><Entity>(&entity);  </span><span>// ❌ 危险！</span></code></pre></div></div></pre>

### ❌ 为什么错？

* `entity` 是栈对象，函数返回时会自动销毁。
* `sp` 不知道这一点，它会在自己销毁时尝试 `delete &entity`。
* 但 `&entity` 不是 `new` 出来的，**不能 `delete`**！
* 结果：**未定义行为（Undefined Behavior）**，程序崩溃。

---

### ✅ 例外：可以用自定义删除器避免 `delete`

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>Entity entity;
</span><span></span><span>auto</span><span> sp = </span><span>std</span><span>::</span><span>shared_ptr</span><span><Entity>(&entity, [](Entity*){});  </span><span>// 空删除器</span></code></pre></div></div></pre>

* 这样 `sp` 不会调用 `delete`，避免崩溃。
* 但你必须确保 `sp` 的生命周期 **不超过 `entity` 的生命周期**，否则变成悬空指针。

👉 这种用法**极少见，不推荐**，容易出错。

---

## ✅ 四、智能指针 vs 栈对象：如何选择？


| 场景                       | 推荐方式                                               |
| -------------------------- | ------------------------------------------------------ |
| 对象生命周期短，函数内使用 | ✅ 直接栈上创建：`Entity e;`                           |
| 需要返回对象给调用者       | ✅ 返回值（RVO/NRVO 优化）或`std::make_unique<Entity>` |
| 多个所有者共享对象         | ✅`std::shared_ptr<Entity>`                            |
| 对象较大，避免拷贝         | ✅`std::unique_ptr<Entity>` 传递所有权                 |

---

## ✅ 五、图解：智能指针与内存位置

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">text</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>栈（Stack）             堆（Heap）
</span>+-------------+       +------------------+
|  ptr         |----→ |   Entity 对象     |
<span>| (智能指针)    |       | (由 </span><span>new</span><span> 创建)     |
</span>+-------------+       +------------------+</code></pre></div></div></pre>

* **智能指针本身**：通常在栈上（局部变量）。
* **智能指针管理的对象**：在堆上。
* 智能指针析构时，自动 `delete` 堆对象。

---

## ✅ 六、总结


| 问题                               | 答案                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| **智能指针管理的对象是在堆上吗？** | ✅ 是的，几乎总是。                                          |
| **为什么？**                       | 因为智能指针是为了管理动态内存（`new` 出来的对象）而设计的。 |
| **能不能管理栈对象？**             | ❌ 不推荐，危险；除非用空删除器，但仍需手动管理生命周期。    |
| **智能指针本身在哪？**             | 通常在栈上，像普通局部变量一样。                             |

---

### 🎯 一句话总结：

> **“智能指针是一个栈上的对象，它负责管理一个堆上的对象的生命周期。”**

它就像一个“自动收垃圾的管家”：

* 它自己住在小屋里（栈）
* 它管理的房子在郊区（堆）
* 房子没人住了，它就自动拆掉（`delete`）

---

### ✅ 正确使用姿势：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code>void func() <span>{
</span><span>    </span><span>auto</span><span> ptr = </span><span>std</span><span>::make_unique<Entity>();  </span><span>// ptr 在栈上，Entity 在堆上</span><span>
</span>    ptr->DoSomething();
<span>} </span><span>// ptr 析构 → 自动 delete Entity</span></code></pre></div></div></pre>

这才是智能指针的正确打开方式！👏

如果你看到有人说“用智能指针代替所有指针”，记住：**它替代的是“手动管理堆内存的原始指针”**，而不是说“所有对象都要上堆”。栈对象依然高效、安全、首选。
