# C++ 中的预编译头文件


## 一、什么是预编译头文件（PCH）？

### ✅ 核心定义：

> **预编译头文件**是将一组**频繁使用且不常变动的头文件**（如 `<vector>`、`<iostream>`、`<windows.h>` 等）**预先编译成编译器可直接加载的二进制格式**，从而避免每次编译源文件时重复解析这些庞大的头文件。

### 🎯 目的：

* **大幅缩短编译时间**
* 尤其适用于大型项目（成百上千个 `.cpp` 文件）


## 二、为什么需要 PCH？——问题背景

在传统编译流程中：

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[36px] sticky top-0 z-10 bg-primary"><div class="flex items-center h-[36px] px-3 text-12 align-middle border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-12 overflow-ellipsis whitespace-nowrap overflow-hidden text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon text-16 size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#pcicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-16 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#pcicon-copy-line"></use></svg></span><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon text-16 size-4"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#pcicon-moon-line"></use></svg></span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon text-16 size-4"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#pcicon-up-line"></use></svg></span></div></div></div></div><pre class="sc-bRKDuR jCSJQZ"><code><span class="token">// main.cpp</span><span>
</span><span></span><span class="token macro directive-hash">#</span><span class="token macro">include</span><span class="token macro"> </span><span class="token macro"><vector></span><span>
</span><span></span><span class="token macro directive-hash">#</span><span class="token macro">include</span><span class="token macro"> </span><span class="token macro"><iostream></span><span>
</span><span></span><span class="token macro directive-hash">#</span><span class="token macro">include</span><span class="token macro"> </span><span class="token macro"><string></span><span>
</span><span></span><span class="token">// ... your code</span></code></pre></div></div></pre>

* 每次编译 `main.cpp`，编译器都要：
  1. 读取 `<vector>`（可能包含数万行代码）
  2. 展开其内部所有 `#include`
  3. 词法/语法分析 → 生成中间表示
* 如果项目有 100 个 `.cpp` 文件都包含 `<vector>`，就要重复解析 100 次！

> 💡 Cherno 指出：**STL 或 Windows API 的代码量可能远超你自己的项目代码**，反复解析极其浪费时间。



## 三、PCH 如何工作？

1. **创建一个“预编译头”源文件**（如 `pch.h` + `pch.cpp`）

   <pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[36px] sticky top-0 z-10 bg-primary"><div class="flex items-center h-[36px] px-3 text-12 align-middle border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-12 overflow-ellipsis whitespace-nowrap overflow-hidden text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon text-16 size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#pcicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-16 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#pcicon-copy-line"></use></svg></span><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon text-16 size-4"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#pcicon-moon-line"></use></svg></span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon text-16 size-4"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#pcicon-up-line"></use></svg></span></div></div></div></div><pre class="sc-bRKDuR jCSJQZ"><code><span class="token">// pch.h</span><span>
   </span><span></span><span class="token macro directive-hash">#</span><span class="token macro">include</span><span class="token macro"> </span><span class="token macro"><vector></span><span>
   </span><span></span><span class="token macro directive-hash">#</span><span class="token macro">include</span><span class="token macro"> </span><span class="token macro"><iostream></span><span>
   </span><span></span><span class="token macro directive-hash">#</span><span class="token macro">include</span><span class="token macro"> </span><span class="token macro"><string></span><span>
   </span><span></span><span class="token macro directive-hash">#</span><span class="token macro">include</span><span class="token macro"> </span><span class="token macro"><windows.h></span><span class="token macro"> </span><span class="token macro">// 巨大但不变</span></code></pre></div></div></pre>

   <pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[36px] sticky top-0 z-10 bg-primary"><div class="flex items-center h-[36px] px-3 text-12 align-middle border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-12 overflow-ellipsis whitespace-nowrap overflow-hidden text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon text-16 size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#pcicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-16 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#pcicon-copy-line"></use></svg></span><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon text-16 size-4"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#pcicon-moon-line"></use></svg></span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon text-16 size-4"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#pcicon-up-line"></use></svg></span></div></div></div></div><pre class="sc-bRKDuR jCSJQZ"><code><span class="token">// pch.cpp</span><span>
   </span><span></span><span class="token macro directive-hash">#</span><span class="token macro">include</span><span class="token macro"> </span><span class="token macro">"pch.h"</span><span class="token macro"> </span><span class="token macro">// 仅此一行</span></code></pre></div></div></pre>
2. **编译器先编译 `pch.cpp` → 生成 `pch.pch`（或 `.gch`）二进制文件**
3. **后续编译其他 `.cpp` 文件时**：

   * 若它们 `#include "pch.h"` 作为**第一个非注释行**
   * 编译器直接加载 `pch.pch`，跳过文本解析阶段
   * **速度提升可达 5\~10 倍**（实测常见）



## 四、使用建议（关键原则）

### ✅ 应该放入 PCH 的内容：

* **标准库头文件**：`<vector>`, `<string>`, `<algorithm>` 等
* **第三方稳定库**：`<GLFW/glfw3.h>`, `<fmt/core.h>`
* **系统 API**：`<windows.h>`, `<unistd.h>`
* **项目中极少修改的通用头**：如 `Log.h`（前提是几乎不变）

### ❌ 不应放入 PCH 的内容：

* **经常修改的项目头文件**
  > 一旦 PCH 中任一头文件变更，整个 PCH 需重新编译，反而拖慢构建
  >
* **仅个别文件使用的依赖**
  > 如只有渲染模块用的 `Vulkan.h`，不应污染全局 PCH
  >
* **会降低代码可读性的内容**
  > 若 `.cpp` 文件只 `#include "pch.h"`，读者无法知道它实际依赖什么
  >

> 📌 Cherno 强调：**PCH 不是“把所有 include 扔进去”的懒人方案**，而是**针对“稳定+高频”依赖的优化工具**。
>


## 五、主流编译器支持


| 编译器            | 使用方式                                                  |
| ----------------- | --------------------------------------------------------- |
| **Visual Studio** | 项目属性 → C/C++ → Precompiled Headers → Use (`pch.h`) |
| **GCC / G++**     | 先编译`pch.h` → 生成 `pch.h.gch`，后续编译自动使用       |
| **Clang**         | 类似 GCC，支持`-include pch.h` 或自动生成                 |


## 六、实际收益（来自 Cherno 实测）

* **无 PCH**：完整构建耗时 **6.2 秒**
* **有 PCH**：完整构建耗时 **1.1 秒**
* **后续增量构建**：从秒级降至 **毫秒级**

> ✅ 结论：**除非是极小的测试项目，否则每个 C++ 项目都应使用 PCH**。
>



## 七、总结：最佳实践清单


| 建议                         | 说明                                        |
| ---------------------------- | ------------------------------------------- |
| ✅**每个项目启用 PCH**       | 小项目也可受益，配置成本低                  |
| ✅**只放稳定、通用的头文件** | STL、系统 API、极少变的工具头               |
| ❌**不要放频繁修改的代码**   | 否则 PCH 频繁重建，适得其反                 |
| ✅**保持 `.cpp` 文件可读性** | 重要依赖仍显式`#include`，或在注释中说明    |
| ✅**命名清晰**               | 如`stdafx.h`（旧 VS）或 `pch.h`（现代通用） |

---

## 💬 最后引用 Cherno 的观点：

> “如果你关心编译时间（谁不关心？），你一定要使用预编译头文件。
> 它不是高级技巧，而是现代 C++ 开发的**基本工程实践**。”

合理使用 PCH，能让你在大型项目中告别“喝咖啡等编译”的痛苦，显著提升开发效率。
