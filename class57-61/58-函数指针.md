# C++ 函数指针（Function Pointers）说明与总结

函数指针是 C++ 中一种强大的机制，它允许我们将**函数当作变量来存储和传递**。这在实现回调、策略模式、事件处理等场景中非常有用。


#### **核心概念总结**


| 概念                         | 说明                                                                                   |
| ---------------------------- | -------------------------------------------------------------------------------------- |
| **什么是函数指针？**         | 指向函数的指针变量，保存的是函数在内存中的地址。                                       |
| **用途**                     | 将函数作为参数传递给其他函数（如`std::sort` 的比较函数）、实现回调机制、构建函数表等。 |
| **语法**                     | `返回类型 (*指针名)(参数列表)`                                                         |
| **获取函数地址**             | 直接使用函数名即可（隐式转换为地址），或加`&` 显式取地址。                             |
| **调用方式**                 | 可以通过指针名直接调用，无需解引用（自动解引用）。                                     |
| **`auto` 推导**              | 使用`auto` 简化函数指针声明。                                                          |
| **`typedef` / `using` 别名** | 提高可读性，避免复杂语法。                                                             |

---

#### 🧩 **基本语法示例**

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>// 原始函数</span><span>
</span><span></span>void HelloWorld() <span>{
</span><span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"Hello, World!\n"</span><span>;
</span>}

<span></span><span>// 函数指针声明并赋值</span><span>
</span><span></span><span>void</span><span> (*funcPtr)() = HelloWorld;  </span><span>// 或 &HelloWorld</span><span>
</span>
<span></span><span>// 调用</span><span>
</span><span>funcPtr();  </span><span>// 输出: Hello, World!</span></code></pre></div></div></pre>


### **可运行完整代码示例**

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>#</span>include<span> </span><iostream><span>
</span><span></span><span>#</span>include<span> </span><vector><span>
</span><span></span><span>#</span>include<span> </span><string><span>
</span>
<span></span><span>// 示例 1：基础函数指针</span><span>
</span><span></span>void SayHello() <span>{
</span><span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"Hello from SayHello!\n"</span><span>;
</span>}

<span></span>void SayGoodbye() <span>{
</span><span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"Goodbye from SayGoodbye!\n"</span><span>;
</span>}

<span></span><span>// 示例 2：带参数的函数</span><span>
</span><span></span>void PrintValue(int value) <span>{
</span><span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"Value: "</span><span> << value << </span><span>"\n"</span><span>;
</span>}

<span></span><span>// 示例 3：作为参数传递（通用遍历函数）</span><span>
</span><span></span>void ForEach(const std::vector<int>& values, void (*func)(int)) <span>{
</span><span>    </span><span>for</span><span> (</span><span>int</span><span> value : values) {
</span>        func(value);
    }
}

<span></span><span>// 示例 4：使用 typedef 定义别名（C 风格）</span><span>
</span><span></span>typedef void (*PrintFunc)(int)<span>;
</span>
<span></span><span>// 示例 5：使用 using（现代 C++ 推荐）</span><span>
</span><span></span><span>using</span><span> CallbackFunc = </span><span>void</span><span> (*)();
</span>
<span></span>int main() <span>{
</span><span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"=== 1. 基础函数指针 ===\n"</span><span>;
</span><span>    </span><span>auto</span><span> func1 = SayHello;         </span><span>// auto 自动推导</span><span>
</span>    CallbackFunc func2 = SayGoodbye;

<span>    func1();  </span><span>// 调用</span><span>
</span>    func2();

<span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"\n=== 2. 带参数的函数指针 ===\n"</span><span>;
</span>    PrintFunc printFunc = PrintValue;
<span>    printFunc(</span>42<span>);
</span>
<span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"\n=== 3. 函数指针作为回调参数 ===\n"</span><span>;
</span><span>    </span><span>std</span><span>::</span><span>vector</span><span><</span><span>int</span><span>> numbers = {</span>1<span>, </span>5<span>, </span>4<span>, </span>2<span>, </span>3<span>};
</span><span>    ForEach(numbers, PrintValue);  </span><span>// 将函数传入</span><span>
</span>
<span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"\n=== 4. 使用 lambda 替代函数指针（更现代） ===\n"</span><span>;
</span><span>    </span><span>// 注意：lambda 如果捕获了外部变量，则不能转为函数指针</span><span>
</span><span>    </span><span>// 但无捕获的 lambda 可以隐式转换为函数指针</span><span>
</span>
<span>    </span><span>auto</span><span> lambda = [](</span><span>int</span><span> value) {
</span><span>        </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"[Lambda] Value: "</span><span> << value << </span><span>"\n"</span><span>;
</span>    };

<span>    </span><span>// 传递无捕获 lambda 给期望函数指针的函数</span><span>
</span>    ForEach(numbers, lambda);

<span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"\n=== 5. 函数指针数组（函数表） ===\n"</span><span>;
</span>    CallbackFunc functionTable[] = {SayHello, SayGoodbye};

<span>    </span><span>for</span><span> (</span><span>int</span><span> i = </span>0<span>; i < </span>2<span>; ++i) {
</span><span>        </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"Calling function "</span><span> << i << </span><span>":\n"</span><span>;
</span>        functionTable[i]();
    }

<span>    </span><span>return</span><span> </span>0<span>;
</span>}</code></pre></div></div></pre>


### **注意事项与限制**

1. **类型必须匹配**
   函数指针的返回类型和参数列表必须与目标函数完全一致。
2. **静态/全局函数**
   普通函数指针只能指向自由函数或静态成员函数，不能直接指向非静态成员函数（需使用 `std::function` 或成员函数指针）。
3. **Lambda 转换限制**
   * **无捕获**的 lambda 可以隐式转换为函数指针。
   * **有捕获**的 lambda 不能转换为函数指针，应使用 `std::function`。
4. **可读性差**
   原始语法较难阅读，推荐使用 `using` 或 `auto` 简化。



### **最佳实践建议**

* ✅ 使用 `using FuncPtr = void(*)(int);` 替代 `typedef`（更清晰）。
* ✅ 在简单回调场景优先考虑无捕获 lambda。
* ✅ 复杂场景（如成员函数、有状态 lambda）使用 `std::function`（头文件 `<functional>`）。
* ✅ 避免过度使用原始函数指针，现代 C++ 更推荐 `std::function` 和模板泛型。

---

### 🔄 **对比：`std::function`（现代替代方案）**

<pre><div class="contain-layout-style rounded-12 bg-capsule relative flex min-h-[2em] flex-col"><div class="rounded-[12px] bg-[#fff]"><div class="h-[42px] sticky top-0 z-10 bg-capsule"><div class="flex items-center h-[42px] p-3 text-[14px] border border-[var(--ty-line-border)]" data-spm-anchor-id="5176.28103460.0.i23.228c2e31FrabiA"><span class="font-medium mr-auto first-letter:uppercase text-[rgba(17,17,51,0.7)]">cpp</span><div class="flex items-center gap-4"><div class="flex items-center justify-center gap-[2px] cursor-pointer text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon size-4 cursor-pointer"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-editingTools-line"></use></svg></span><span class="mt-[2px] text-[12px]">编辑</span></div><div class="flex cursor-pointer gap-1 text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><span role="img" class="anticon"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-sun-line"></use></svg></span></div><span role="img" tabindex="-1" class="anticon flex cursor-pointer items-center text-[rgba(17,17,51,0.7)] hover:text-[#4433ff]"><svg width="1em" height="1em" fill="currentColor" aria-hidden="true" focusable="false" class=""><use xlink:href="#appicon-copy-line"></use></svg></span></div></div></div><pre><code><span>#</span>include<span> </span><functional><span>
</span>
<span></span><span>// 更灵活的通用可调用对象包装器</span><span>
</span><span></span><span>std</span><span>::function<</span><span>void</span><span>(</span><span>int</span><span>)> func = [](</span><span>int</span><span> x) { 
</span><span>    </span><span>std</span><span>::</span><span>cout</span><span> << </span><span>"Captured value: "</span><span> << x << </span><span>"\n"</span><span>; 
</span>};
<span>func(</span>100<span>); </span><span>// 即使有捕获也能工作</span></code></pre></div></div></pre>

> `std::function` 是类型擦除的包装器，功能更强但有轻微性能开销；而函数指针是零成本抽象，性能最高。
>


### 总结


| 特性        | 函数指针               | `std::function`         |
| ----------- | ---------------------- | ----------------------- |
| 性能        | ⚡️ 极快（裸指针）    | 🐢 略慢（类型擦除）     |
| 功能        | ❌ 仅支持自由/静态函数 | ✅ 支持任意可调用对象   |
| 捕获 lambda | ❌ 仅限无捕获          | ✅ 支持有捕获           |
| 推荐场景    | 回调、性能敏感、C 兼容 | 通用逻辑、GUI、事件系统 |

> 🔔 **结论：了解函数指针是掌握 C/C++ 的基础，但在现代 C++ 中，优先考虑 `std::function` 和 lambda 表达式。**
>
